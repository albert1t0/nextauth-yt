{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Next.js Project with TypeScript",
        "description": "Initialize a new Next.js project with TypeScript and set up the basic project structure.",
        "details": "Use `create-next-app` with the App Router and TypeScript template. \n```bash\nnpx create-next-app@latest my-auth-app --typescript --eslint --tailwind --src-dir --app --import-alias \"@/*\"\ncd my-auth-app\n```\nEnsure basic linting and formatting tools are configured.",
        "testStrategy": "Verify that the Next.js application runs successfully in development mode (`npm run dev`). Check that TypeScript compilation works without errors.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Setup Prisma ORM and PostgreSQL Database",
        "description": "Install and configure Prisma ORM with a PostgreSQL database. Define the initial User schema.",
        "details": "Install Prisma CLI and Client: `npm install prisma --save-dev` and `npm install @prisma/client`. \nInitialize Prisma: `npx prisma init --datasource-provider postgresql`. \nConfigure `DATABASE_URL` in `.env`. \nDefine User model in `prisma/schema.prisma`:\n```prisma\nmodel User {\n  id        String   @id @default(cuid())\n  email     String   @unique\n  name      String?\n  password  String\n  emailVerified DateTime? // To store verification timestamp\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n```\nRun `npx prisma migrate dev --name init` to create the initial migration and apply it.",
        "testStrategy": "Verify that Prisma can connect to the PostgreSQL database. Check that the `User` table is created in the database with the correct columns after running migrations.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Install and Configure NextAuth.js",
        "description": "Install and configure NextAuth.js for session management and authentication providers.",
        "details": "Install NextAuth.js: `npm install next-auth`. \nCreate `app/api/auth/[...nextauth]/route.ts`. \nConfigure NextAuth with a Credentials provider. \n```typescript\n// app/api/auth/[...nextauth]/route.ts\nimport NextAuth from 'next-auth';\nimport CredentialsProvider from 'next-auth/providers/credentials';\n// ... (import Prisma adapter and bcrypt later)\n\nexport const authOptions = {\n  providers: [\n    CredentialsProvider({\n      name: 'Credentials',\n      credentials: {\n        email: { label: \"Email\", type: \"text\" },\n        password: { label: \"Password\", type: \"password\" }\n      },\n      async authorize(credentials) {\n        // Logic to verify credentials will be added in later tasks\n        // For now, can return null or a mock user for setup\n        if (credentials?.email && credentials?.password) {\n          // Placeholder: Actual DB lookup and password check later\n          // const user = await prisma.user.findUnique({ where: { email: credentials.email } });\n          // if (user && await bcrypt.compare(credentials.password, user.password)) return user;\n          return null; \n        }\n        return null;\n      }\n    })\n  ],\n  // session: { strategy: 'jwt' }, // Optional: JWT strategy\n  // pages: { signIn: '/login' }, // Optional: Custom login page\n};\n\nconst handler = NextAuth(authOptions);\nexport { handler as GET, handler as POST };\n```\nWrap the root layout with `<SessionProvider>` from `next-auth/react`.",
        "testStrategy": "Verify that the NextAuth.js API route is accessible (e.g., `/api/auth/signin`). Check for any console errors related to NextAuth.js setup.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Setup shadcn/ui for UI Components",
        "description": "Install and set up shadcn/ui for reusable UI components.",
        "details": "Follow the shadcn/ui installation guide for Next.js: `npx shadcn-ui@latest init`. \nConfigure `tailwind.config.js` and `globals.css` as per shadcn/ui documentation. \nInstall basic components like `button`, `input`, `label`, `card`:\n`npx shadcn-ui@latest add button input label card form`.",
        "testStrategy": "Verify that shadcn/ui components can be imported and rendered correctly in a sample page. Check that Tailwind CSS styles are applied.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Install Zod for Validation",
        "description": "Install Zod for schema validation.",
        "details": "Install Zod: `npm install zod`. No specific configuration needed beyond installation. It will be used in API routes and potentially forms.",
        "testStrategy": "Create a simple Zod schema and test its validation logic in a test file or a temporary route. Ensure type inference works correctly.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Setup Email Sending Service (Resend/Nodemailer)",
        "description": "Install and configure an email sending service (Resend or Nodemailer).",
        "details": "Choose between Resend or Nodemailer. For Resend: `npm install resend`. \nGet API key from Resend and add it to `.env` (e.g., `RESEND_API_KEY`). \nCreate a utility function for sending emails, e.g., `lib/email.ts`.\n```typescript\n// lib/email.ts\nimport { Resend } from 'resend';\n\nconst resend = new Resend(process.env.RESEND_API_KEY);\n\nexport const sendVerificationEmail = async (email: string, token: string) => {\n  const verificationLink = `${process.env.NEXT_PUBLIC_APP_URL}/api/auth/verify-email?token=${token}`;\n  await resend.emails.send({\n    from: 'onboarding@resend.dev', // Replace with your domain\n    to: email,\n    subject: 'Verify your email address',\n    html: `<p>Click <a href=\"${verificationLink}\">here</a> to verify your email.</p>`\n  });\n};\n```\nEnsure `NEXT_PUBLIC_APP_URL` is set in `.env` (e.g., `http://localhost:3000`).",
        "testStrategy": "Send a test email to a controlled email address using the configured service. Verify that the email is received and the content is correct.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement User Registration API Endpoint",
        "description": "Implement the user registration API endpoint, including email/password validation with Zod and password hashing.",
        "details": "Create an API route `app/api/auth/register/route.ts`. \nUse Zod to validate `email` and `password`. \nInstall bcrypt: `npm install bcryptjs` and `@types/bcryptjs`. \nHash the password using bcrypt before saving to the database. \nCheck if user already exists. \n```typescript\n// app/api/auth/register/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { z } from 'zod';\nimport bcrypt from 'bcryptjs';\nimport prisma from '@/lib/prisma'; // Assuming prisma client is exported from lib/prisma\n\nconst registerSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(8),\n});\n\nexport async function POST(req: NextRequest) {\n  try {\n    const body = await req.json();\n    const { email, password } = registerSchema.parse(body);\n\n    const existingUser = await prisma.user.findUnique({ where: { email } });\n    if (existingUser) {\n      return NextResponse.json({ error: 'User already exists' }, { status: 400 });\n    }\n\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const user = await prisma.user.create({\n      data: { email, password: hashedPassword },\n    });\n    // Email verification sending will be handled in a subsequent task\n    return NextResponse.json({ message: 'User registered successfully. Please verify your email.' }, { status: 201 });\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return NextResponse.json({ error: error.errors }, { status: 400 });\n    }\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });\n  }\n}\n```",
        "testStrategy": "Test the endpoint with valid and invalid data (e.g., malformed email, short password). Verify that new users are created in the database with hashed passwords and appropriate error responses are returned.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement User Login Logic in NextAuth.js",
        "description": "Implement the user login API endpoint within NextAuth.js `authorize` function, including email/password validation and password comparison.",
        "details": "Update the `authorize` function in `app/api/auth/[...nextauth]/route.ts`. \nUse Prisma to find the user by email. \nUse bcrypt to compare the provided password with the stored hashed password. \nReturn the user object if credentials are valid, otherwise return null. \n```typescript\n// app/api/auth/[...nextauth]/route.ts (update authorize function)\n// ... imports (prisma, bcrypt)\nasync authorize(credentials) {\n  if (!credentials?.email || !credentials?.password) return null;\n\n  const user = await prisma.user.findUnique({\n    where: { email: credentials.email },\n  });\n\n  if (!user || !user.password) return null;\n  // Add check for emailVerified status after verification flow is implemented\n  // if (!user.emailVerified) { throw new Error('Please verify your email before logging in.'); }\n\n  const isValidPassword = await bcrypt.compare(credentials.password, user.password);\n  if (!isValidPassword) return null;\n\n  return { id: user.id, email: user.email, name: user.name, emailVerified: user.emailVerified }; // Return necessary user fields for session\n}\n// ... rest of authOptions\n```\nEnsure NextAuth.js is configured to use Prisma Adapter if you want database sessions: `npm install @next-auth/prisma-adapter`. Then add `adapter: PrismaAdapter(prisma)` to `authOptions`.",
        "testStrategy": "Test login with valid and invalid credentials. Verify that NextAuth.js creates a session cookie upon successful login. Check that users who are not verified (once that logic is in) cannot log in.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          5,
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement User Logout Functionality",
        "description": "Implement user logout functionality using NextAuth.js `signOut` method.",
        "details": "Use the `signOut` function from `next-auth/react` in a UI component (e.g., a logout button). \n```typescript\n// Example in a component\nimport { signOut } from 'next-auth/react';\n\nconst LogoutButton = () => {\n  return <button onClick={() => signOut({ callbackUrl: '/' })}>Sign Out</button>;\n};\n```\nNo backend API changes are typically needed as NextAuth.js handles this via its routes.",
        "testStrategy": "Log in as a user, then click the logout button. Verify that the session is terminated and the user is redirected (e.g., to the homepage).",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Email Verification Token Generation and Storage",
        "description": "Implement logic to generate and store email verification tokens. This might involve adding a new model or fields to the User model.",
        "details": "Create a new Prisma model for verification tokens or add fields to the User model. A separate model is cleaner for managing token expiry.\n```prisma\n// prisma/schema.prisma (add this model)\nmodel VerificationToken {\n  id        String   @id @default(cuid())\n  identifier String   // Typically user's email or ID\n  token     String   @unique\n  expires   DateTime\n\n  @@unique([identifier, token])\n}\n```\nRun `npx prisma migrate dev --name add_verification_token`. \nCreate a utility function to generate a unique token (e.g., using `crypto.randomBytes`). Store the token with an expiry date linked to the user.",
        "testStrategy": "Verify that tokens can be generated, stored in the database with an expiry, and retrieved. Test uniqueness constraints.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Send Verification Email on Registration",
        "description": "Modify the registration process to generate a verification token and send a verification email to the new user.",
        "details": "In `app/api/auth/register/route.ts`, after successfully creating the user (but before they can log in, or mark them as unverified):\n1. Generate a verification token using the utility from task 10.\n2. Store the token associated with the user's email/ID.\n3. Use the email sending utility (task 6) to send an email containing a link with this token. The link should point to an API endpoint for verification (task 12).\n```typescript\n// In app/api/auth/register/route.ts, after user creation:\n// ...\nconst verificationToken = crypto.randomBytes(32).toString('hex');\nconst expires = new Date(Date.now() + 3600 * 1000); // 1 hour expiry\n\nawait prisma.verificationToken.create({\n  data: {\n    identifier: user.email, // or user.id\n    token: verificationToken,\n    expires,\n  },\n});\n\nawait sendVerificationEmail(user.email, verificationToken);\n// ...\n```\nUser's `emailVerified` field should initially be null or false.",
        "testStrategy": "Register a new user. Verify that a verification token is created in the database. Verify that an email is sent to the user's email address with a correctly formatted verification link.",
        "priority": "high",
        "dependencies": [
          7,
          6,
          10
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Email Verification API Endpoint",
        "description": "Create an API endpoint to handle email verification. This endpoint will receive the token, validate it, and mark the user's email as verified.",
        "details": "Create `app/api/auth/verify-email/route.ts`. \nThis GET endpoint will take the `token` as a query parameter. \n1. Find the token in the `VerificationToken` table. \n2. Check if it's valid and not expired. \n3. If valid, find the associated user and update their `emailVerified` status/timestamp in the `User` table. \n4. Delete the used token. \n5. Redirect the user to the login page or a success page. \n```typescript\n// app/api/auth/verify-email/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport prisma from '@/lib/prisma';\n\nexport async function GET(req: NextRequest) {\n  const token = req.nextUrl.searchParams.get('token');\n  if (!token) {\n    return NextResponse.redirect(new URL('/?error=MissingToken', req.url));\n  }\n\n  const verificationToken = await prisma.verificationToken.findUnique({\n    where: { token },\n  });\n\n  if (!verificationToken || verificationToken.expires < new Date()) {\n    return NextResponse.redirect(new URL('/?error=InvalidOrExpiredToken', req.url));\n  }\n\n  await prisma.user.update({\n    where: { email: verificationToken.identifier }, // Assuming identifier is email\n    data: { emailVerified: new Date() },\n  });\n\n  await prisma.verificationToken.delete({ where: { id: verificationToken.id } });\n\n  return NextResponse.redirect(new URL('/login?verified=true', req.url));\n}\n```",
        "testStrategy": "Generate a verification link (manually or via registration). Click the link. Verify that the user's `emailVerified` status is updated in the database and the token is deleted. Test with invalid/expired tokens.",
        "priority": "high",
        "dependencies": [
          2,
          10
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Block Login for Unverified Emails",
        "description": "Update login logic to prevent users from logging in if their email is not verified.",
        "details": "In `app/api/auth/[...nextauth]/route.ts`, within the `authorize` function, add a check for `user.emailVerified` before returning the user object.\n```typescript\n// In authorize function of NextAuth options:\n// ...\n  const user = await prisma.user.findUnique({ where: { email: credentials.email } });\n  if (!user || !user.password) return null;\n\n  if (!user.emailVerified) {\n    // Option 1: Return null to indicate login failure\n    // return null; \n    // Option 2: Throw a specific error that can be caught by NextAuth and displayed to user\n    throw new Error('EmailNotVerified'); \n  }\n// ... rest of password check and return user\n```\nHandle the `EmailNotVerified` error on the client-side if using the error throwing approach.",
        "testStrategy": "Attempt to log in with a user account that has been registered but not yet verified. Verify that login fails and an appropriate message is shown. Then, verify the email and attempt login again; it should succeed.",
        "priority": "medium",
        "dependencies": [
          8,
          12
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Create Reusable Auth Form Components",
        "description": "Create reusable React components for authentication forms (Registration, Login) using shadcn/ui and Zod for client-side validation.",
        "details": "Create components like `AuthForm.tsx`, `RegistrationForm.tsx`, `LoginForm.tsx`. \nUse shadcn/ui components (`Input`, `Button`, `Label`, `Card`, `Form`). \nIntegrate Zod for client-side form validation using libraries like `react-hook-form` with its Zod resolver (`@hookform/resolvers/zod`). \n```typescript\n// Example structure for LoginForm.tsx\n'use client';\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport * as z from 'zod';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';\nimport { signIn } from 'next-auth/react';\nimport { useRouter } from 'next/navigation';\n\nconst loginSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(1, 'Password is required'),\n});\n\nexport function LoginForm() {\n  const router = useRouter();\n  const form = useForm<z.infer<typeof loginSchema>>({\n    resolver: zodResolver(loginSchema),\n    defaultValues: { email: '', password: '' },\n  });\n\n  async function onSubmit(values: z.infer<typeof loginSchema>) {\n    const result = await signIn('credentials', {\n      redirect: false,\n      email: values.email,\n      password: values.password,\n    });\n    if (result?.ok) {\n      router.push('/dashboard'); // Or desired redirect path\n    } else {\n      // Handle error (e.g., display message from result.error)\n      form.setError('root', { message: result?.error || 'Login failed' });\n    }\n  }\n\n  return (\n    <Form {...form}>\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n        {/* FormFields for email and password */}\n        <Button type=\"submit\">Login</Button>\n      </form>\n    </Form>\n  );\n}\n```\nSimilarly create `RegistrationForm.tsx` that calls the `/api/auth/register` endpoint.",
        "testStrategy": "Verify that forms render correctly. Test client-side validation with Zod (e.g., empty fields, invalid email format). Ensure form submission calls the correct API endpoints.",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Develop User Registration Page",
        "description": "Develop the User Registration page (`/register`) using the created form components.",
        "details": "Create a Next.js page route `app/register/page.tsx`. \nImport and use the `RegistrationForm` component. \nHandle form submission, API responses, and display success/error messages to the user. \nRedirect or guide user on successful registration (e.g., message to check email).",
        "testStrategy": "Navigate to the `/register` page. Test the registration flow end-to-end. Verify UI feedback for successful registration and for errors (e.g., user already exists, validation errors).",
        "priority": "high",
        "dependencies": [
          14,
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Develop User Login Page",
        "description": "Develop the User Login page (`/login`) using the created form components.",
        "details": "Create a Next.js page route `app/login/page.tsx`. \nImport and use the `LoginForm` component. \nHandle form submission using `signIn` from `next-auth/react`. \nRedirect user to a protected page (e.g., `/dashboard`) on successful login. Display error messages on login failure.",
        "testStrategy": "Navigate to the `/login` page. Test login with valid and invalid credentials. Verify redirection on successful login and error messages on failure. Test login for unverified users (should fail with message).",
        "priority": "high",
        "dependencies": [
          14,
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Implement Protected Routes Middleware",
        "description": "Implement middleware to protect specific routes (e.g., `/dashboard`) from unauthenticated access using NextAuth.js.",
        "details": "Create `middleware.ts` in the root or `src` directory. \nUse `withAuth` HOF from `next-auth/middleware` or check `getToken` from `next-auth/jwt`. \n```typescript\n// middleware.ts\nexport { default } from \"next-auth/middleware\"\n\nexport const config = {\n  matcher: ['/dashboard/:path*', '/profile'], // Add all routes to protect\n};\n```\nAlternatively, for more complex logic:\n```typescript\n// middleware.ts\nimport { getToken } from 'next-auth/jwt';\nimport { NextRequest, NextResponse } from 'next/server';\n\nexport async function middleware(req: NextRequest) {\n  const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });\n\n  if (req.nextUrl.pathname.startsWith('/dashboard')) {\n    if (!token) {\n      const loginUrl = new URL('/login', req.url);\n      loginUrl.searchParams.set('callbackUrl', req.nextUrl.pathname);\n      return NextResponse.redirect(loginUrl);\n    }\n    // Add role-based checks if needed: if (token.role !== 'admin') return NextResponse.redirect('/');\n  }\n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: ['/dashboard/:path*', '/profile'],\n};\n```\nEnsure `NEXTAUTH_SECRET` is set in `.env`.",
        "testStrategy": "Attempt to access a protected route (e.g., `/dashboard`) without being logged in; verify redirection to the login page. Log in and access the protected route; verify access is granted.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Create Sample Dashboard Page (Protected)",
        "description": "Create a sample protected page (e.g., `/dashboard`) that displays user information and a logout button.",
        "details": "Create `app/dashboard/page.tsx`. \nUse `useSession` hook from `next-auth/react` to access session data and display user information (e.g., email). \nInclude the `LogoutButton` component (from task 9). \nThis page should only be accessible to authenticated users due to the middleware (task 17).",
        "testStrategy": "Log in and navigate to `/dashboard`. Verify that user-specific information is displayed. Test the logout button from this page. Attempt to access `/dashboard` when logged out and verify redirection.",
        "priority": "medium",
        "dependencies": [
          17,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Add Password Reset Token Model to Prisma Schema",
        "description": "Update the Prisma schema to include a model for storing password reset tokens. The model should include fields for an identifier (email), the token itself, and an expiration date.",
        "details": "Modify the `prisma/schema.prisma` file to add a new `PasswordResetToken` model. This model will store the necessary information for password reset functionality.\n\nThe model definition should be as follows:\n```prisma\nmodel PasswordResetToken {\n  id        String   @id @default(cuid())\n  email     String   // User's email address associated with the token\n  token     String   @unique // The cryptographically secure reset token\n  expires   DateTime // The timestamp when this token will expire\n\n  // Optional: If you need to quickly find tokens by email, consider adding an index:\n  // @@index([email])\n}\n```\nAfter adding the model to `prisma/schema.prisma`, run the following Prisma commands in your terminal:\n1. To create and apply a new migration: `npx prisma migrate dev --name add_password_reset_token_model`\n2. To regenerate the Prisma Client to include the new model: `npx prisma generate`\nThis will update your database schema and make the `PasswordResetToken` model available in your Prisma Client for database operations.",
        "testStrategy": "1. After defining the model in `prisma/schema.prisma`, run `npx prisma migrate dev --name add_password_reset_token_model`. Verify that the migration applies successfully without errors.\n2. Run `npx prisma generate` to update the Prisma Client.\n3. Inspect your PostgreSQL database (e.g., using `psql` or a database GUI tool) to confirm that a new table named `PasswordResetToken` has been created.\n4. Verify that the `PasswordResetToken` table has the following columns with appropriate types: `id` (String, Primary Key), `email` (String), `token` (String, Unique), `expires` (DateTime).\n5. Write a temporary test script or use a tool like Prisma Studio (`npx prisma studio`) to interact with the new table:\n    a. Attempt to create a new record in the `PasswordResetToken` table with valid data. Verify success.\n    b. Attempt to create a second record with the same `token` value as the first. Verify that this operation fails due to the unique constraint on the `token` field.\n    c. Attempt to create a second record with a different `token` but the same `email`. Verify success (as `email` is not unique by itself).\n    d. Read the created records to ensure data integrity.\n    e. Delete the test records.",
        "status": "done",
        "dependencies": [
          2,
          10
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Implement Password Reset Request API Endpoint",
        "description": "Create an API endpoint to handle password reset requests. This endpoint will receive a user's email, generate a secure password reset token, save it to the database with an expiration date, and send an email to the user with a link to reset their password.",
        "details": "Create a new API route at `app/api/auth/request-password-reset/route.ts` to handle POST requests.\n1.  **Input Validation**: The endpoint should expect a JSON body containing an `email` field. Use Zod for validating the email format.\n2.  **User Lookup**: Query the database using Prisma to find a user matching the provided email.\n3.  **Token Generation**:\n    *   If a user is found, generate a cryptographically secure, unique token (e.g., using `crypto.randomBytes(32).toString('hex')`).\n    *   Define an expiration period for the token (e.g., 1 hour from the current time).\n4.  **Token Storage**:\n    *   Before saving a new token, check for and invalidate/delete any existing, non-expired password reset tokens for the same email in the `PasswordResetToken` table to ensure only one active reset link per user.\n    *   Store the new token, the user's email, and its expiration timestamp in the `PasswordResetToken` table (defined in Task 19).\n5.  **Email Notification**:\n    *   Construct the password reset URL (e.g., `YOUR_APP_URL/reset-password?token=<GENERATED_TOKEN>`).\n    *   Send an email to the user's email address containing this unique password reset link. This requires an email sending service (e.g., Resend, Nodemailer) to be configured. The email should clearly state the purpose of the link and its expiration.\n6.  **Security Consideration**: To prevent user enumeration, the API should always return a generic success message (e.g., \"If an account with that email exists, a password reset link has been sent.\"), regardless of whether the email was found in the database or an error occurred during email sending (unless it's a client-side validation error). Log internal errors for monitoring.\n7.  **Error Handling**: Implement try-catch blocks for database operations and email sending. Log errors server-side.\n\nExample structure for the route handler:\n```typescript\n// app/api/auth/request-password-reset/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { z } from 'zod';\nimport prisma from '@/lib/prisma'; // Assuming prisma client\nimport crypto from 'crypto';\n// import { sendPasswordResetEmail } from '@/lib/email'; // Assume an email sending utility\n\nconst requestPasswordResetSchema = z.object({\n  email: z.string().email({ message: 'Invalid email address' }),\n});\n\nexport async function POST(req: NextRequest) {\n  try {\n    const body = await req.json();\n    const validation = requestPasswordResetSchema.safeParse(body);\n\n    if (!validation.success) {\n      return NextResponse.json({ errors: validation.error.flatten().fieldErrors }, { status: 400 });\n    }\n\n    const { email } = validation.data;\n\n    const user = await prisma.user.findUnique({\n      where: { email },\n    });\n\n    if (user) {\n      // Invalidate old tokens for this email\n      await prisma.passwordResetToken.deleteMany({\n        where: { email: email },\n      });\n\n      const token = crypto.randomBytes(32).toString('hex');\n      const expires = new Date(Date.now() + 3600 * 1000); // 1 hour from now\n\n      await prisma.passwordResetToken.create({\n        data: {\n          email,\n          token,\n          expires,\n        },\n      });\n\n      // const resetLink = `${process.env.NEXTAUTH_URL}/reset-password?token=${token}`;\n      // await sendPasswordResetEmail(email, resetLink); // Implement this function\n    }\n\n    // Always return a generic success message to prevent user enumeration\n    return NextResponse.json({ message: 'If your email is in our system, you will receive a password reset link.' }, { status: 200 });\n\n  } catch (error) {\n    console.error('Password reset request error:', error);\n    // Return generic message even on server error for security, but log it\n    return NextResponse.json({ message: 'If your email is in our system, you will receive a password reset link.' }, { status: 200 });\n  }\n}\n```",
        "testStrategy": "1.  **Successful Request**:\n    *   Send a POST request to `/api/auth/request-password-reset` with the email of an existing, registered user.\n    *   **Expected**: HTTP 200 OK response with a generic success message.\n    *   **Verification**:\n        *   Check the `PasswordResetToken` table in the database: a new record should exist for the user's email, containing a unique token and an expiration timestamp approximately 1 hour in the future.\n        *   (If email sending is mocked/testable) Verify that an email was dispatched to the user's address containing a link like `YOUR_APP_URL/reset-password?token=<TOKEN_VALUE>`.\n2.  **Non-Existent User Email**:\n    *   Send a POST request with an email address not registered in the system.\n    *   **Expected**: HTTP 200 OK response with the same generic success message (to prevent user enumeration).\n    *   **Verification**:\n        *   Check the `PasswordResetToken` table: no new token should be generated for this email.\n        *   No email should be sent.\n3.  **Invalid Email Format**:\n    *   Send a POST request with an invalid email format (e.g., \"testuser\", \"test@.com\").\n    *   **Expected**: HTTP 400 Bad Request response with a JSON body detailing the validation errors (e.g., `{ \"errors\": { \"email\": [\"Invalid email address\"] } }`).\n4.  **Missing Email Field**:\n    *   Send a POST request with an empty body or a body missing the `email` field.\n    *   **Expected**: HTTP 400 Bad Request response with a JSON body detailing the validation errors.\n5.  **Token Invalidation on Subsequent Request**:\n    *   Request a password reset for a user. Verify a token (Token A) is created.\n    *   Request another password reset for the same user.\n    *   **Expected**: HTTP 200 OK.\n    *   **Verification**:\n        *   Check the `PasswordResetToken` table: Token A should be deleted or marked as invalid. A new token (Token B) should be present and active for the user.\n6.  **Database/Service Error Simulation (if possible)**:\n    *   Simulate a database write failure or email sending failure (if these can be mocked).\n    *   **Expected**: The endpoint should still ideally return a generic success message (HTTP 200) to the client to prevent information leakage, but log the internal error server-side for administrators.",
        "status": "done",
        "dependencies": [
          2,
          19
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Create 'Forgot Password' Page",
        "description": "Develop the 'Forgot Password' page (`/forgot-password`) where users can submit their email address to initiate the password reset process by calling the password reset request API.",
        "details": "1. Create a new Next.js page route at `app/forgot-password/page.tsx`.\n2. Design and implement a form that includes:\n    - An input field for the user's email address.\n    - A submit button (e.g., 'Send Reset Link').\n3. Utilize reusable form components from Task 14 (e.g., `Input`, `Button`, `Form` from shadcn/ui) and client-side validation patterns using Zod and `react-hook-form`.\n    - Define a Zod schema for the email field (e.g., `z.object({ email: z.string().email({ message: 'Invalid email address' }) })`).\n4. On form submission:\n    - Prevent default form submission.\n    - Make a POST request to the `/api/auth/request-password-reset` endpoint (implemented in Task 20). The request body should be a JSON object containing the email: `{ \"email\": \"user@example.com\" }`.\n    - Use a library like `axios` or the native `fetch` API for the request.\n5. Handle API responses:\n    - On successful API response (e.g., HTTP 200), display a generic success message to the user, such as 'If an account with that email exists, a password reset link has been sent. Please check your inbox.' This is important for security to prevent email enumeration.\n    - On API error or network failure, display an appropriate error message to the user (e.g., 'An error occurred. Please try again.').\n    - Manage loading states for the form submission.\n6. Ensure the page is publicly accessible and does not require authentication.",
        "testStrategy": "1. Navigate to the `/forgot-password` page in a browser.\n2. **UI Verification**:\n    - Verify that the page renders correctly with an email input field and a submit button.\n3. **Client-Side Validation**:\n    - Attempt to submit the form with an empty email field. Verify that a client-side validation error message is displayed (e.g., 'Email is required').\n    - Enter an improperly formatted email (e.g., 'test@invalid') and attempt to submit. Verify that a client-side validation error message for invalid email format is displayed.\n4. **Successful Password Reset Request**:\n    - Enter the email address of a known, existing user and submit the form.\n    - **Expected**: A generic success message should be displayed (e.g., 'If an account with that email exists, a password reset link has been sent.').\n    - **Verification**: Check the browser's network developer tools to confirm that a POST request was made to `/api/auth/request-password-reset` with the correct email in the payload.\n5. **Password Reset Request for Non-Existing User**:\n    - Enter an email address that is known not to be registered in the system and submit the form.\n    - **Expected**: The same generic success message as in step 4 should be displayed to prevent email enumeration.\n    - **Verification**: Check the browser's network developer tools to confirm the API call was made.\n6. **API Error Handling (if mockable or testable)**:\n    - If the `/api/auth/request-password-reset` endpoint returns an error (e.g., 500 server error), verify that an appropriate error message is displayed on the page.\n7. **Accessibility**:\n    - Perform basic accessibility checks (e.g., keyboard navigation, proper labels for form fields).",
        "status": "done",
        "dependencies": [
          20,
          14
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Implement Password Reset API Endpoint",
        "description": "Implement an API endpoint to handle the actual password reset. This endpoint will receive the reset token and the new password, validate the token, hash the new password, and update the user's record in the database.",
        "details": "1.  **API Route Creation**: Create a new API route at `app/api/auth/reset-password/route.ts` to handle POST requests.\n2.  **Input Validation**: The endpoint should expect a JSON body containing `token` (string) and `newPassword` (string). Use Zod (from Task 5) to validate the `token` (e.g., non-empty string) and `newPassword` (e.g., minimum length 8 characters, any other complexity rules).\n3.  **Token Validation**: \n    *   Query the `PasswordResetToken` table (defined in Task 19) using Prisma (from Task 2) to find the provided `token`.\n    *   If the token is not found or if `new Date() > token.expires`, return a 400 Bad Request error (e.g., \"Invalid or expired password reset token\").\n4.  **User Lookup**: \n    *   If the token is valid, retrieve the `email` associated with the token.\n    *   Query the `User` table using Prisma to find the user by this `email`.\n    *   If no user is found for the email (which should be rare if the token is valid), return a 404 Not Found error or a generic error.\n5.  **Password Hashing**: \n    *   Hash the `newPassword` using `bcryptjs` (similar to Task 7). Generate a new salt and hash the password.\n6.  **Update User Record**: \n    *   Update the user's `password` field in the `User` table with the new hashed password.\n    *   Optionally, update the user's `updatedAt` timestamp.\n7.  **Token Invalidation**: \n    *   Delete the used `PasswordResetToken` from the database to prevent it from being used again.\n8.  **Response**: \n    *   On successful password reset, return a 200 OK response with a success message (e.g., `{ message: \"Password has been reset successfully.\" }`).\n    *   Return appropriate error responses (e.g., 400 for validation errors, invalid/expired token; 404 if user not found; 500 for unexpected server errors).",
        "testStrategy": "1.  **Successful Password Reset**:\n    *   Manually add a valid, non-expired `PasswordResetToken` to the database for an existing user.\n    *   Send a POST request to `/api/auth/reset-password` with the correct `token` and a valid `newPassword`.\n    *   **Expected**: HTTP 200 OK response.\n    *   **Verification**: Check the `User` table to confirm the password hash has changed. Attempt to log in with the new password. Verify the `PasswordResetToken` used has been deleted from the database.\n2.  **Invalid Token**:\n    *   Send a POST request with a `token` that does not exist in the `PasswordResetToken` table.\n    *   **Expected**: HTTP 400 Bad Request (or similar) error response.\n    *   **Verification**: User's password should remain unchanged.\n3.  **Expired Token**:\n    *   Manually add a `PasswordResetToken` to the database with an `expires` timestamp in the past.\n    *   Send a POST request with this expired `token`.\n    *   **Expected**: HTTP 400 Bad Request (or similar) error response indicating the token is expired.\n    *   **Verification**: User's password should remain unchanged.\n4.  **Invalid New Password (Validation Failure)**:\n    *   Send a POST request with a valid token but a `newPassword` that fails Zod validation (e.g., too short).\n    *   **Expected**: HTTP 400 Bad Request with a validation error message.\n    *   **Verification**: User's password should remain unchanged.\n5.  **Missing Token or New Password in Payload**:\n    *   Send a POST request missing the `token` or `newPassword` field in the JSON body.\n    *   **Expected**: HTTP 400 Bad Request with a validation error message.\n    *   **Verification**: User's password should remain unchanged.\n6.  **Attempt to Reuse Token**:\n    *   After a successful password reset, attempt to send another POST request using the same `token`.\n    *   **Expected**: HTTP 400 Bad Request (or similar) error, as the token should have been deleted.\n    *   **Verification**: User's password should not be affected by the second attempt.",
        "status": "done",
        "dependencies": [
          2,
          5,
          7,
          19
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Create 'Reset Password' Page",
        "description": "Develop the 'Reset Password' page (`/reset-password/[token]`) that allows users to set a new password after verifying a reset token received via email. The page will capture the token from URL parameters and include a form for the new password.",
        "details": "1.  **Page Route Creation**: Create a dynamic Next.js page route at `app/reset-password/[token]/page.tsx`.\n2.  **Token Extraction**: Implement logic to extract the `token` from the URL parameters. This can be done using `useParams` from `next/navigation` in a client component or the `params` prop if it's a server component rendering a client component that needs the token.\n3.  **Form Implementation**: \n    *   Design and implement a form containing two password input fields: 'New Password' and 'Confirm New Password', and a 'Reset Password' submit button.\n    *   Utilize reusable form components developed in Task 14 (e.g., `Input`, `Button`, `Form` from shadcn/ui).\n    *   Implement client-side validation using Zod (from Task 5) and `react-hook-form`. Define a Zod schema to ensure both password fields are non-empty, meet minimum length/complexity requirements, and that the 'Confirm New Password' field matches the 'New Password' field. Example schema:\n        ```typescript\n        import * as z from 'zod';\n\n        const passwordResetSchema = z.object({\n          newPassword: z.string().min(8, { message: 'Password must be at least 8 characters long' }),\n          confirmPassword: z.string().min(8, { message: 'Password must be at least 8 characters long' })\n        }).refine(data => data.newPassword === data.confirmPassword, {\n          message: \"Passwords don't match\",\n          path: [\"confirmPassword\"],\n        });\n        ```\n4.  **API Interaction**: On successful client-side validation and form submission, make a POST request to the 'Password Reset API Endpoint' (defined in Task 22). The request body should include the `token` (extracted from the URL) and the `newPassword`.\n5.  **User Feedback and Redirection**: \n    *   Upon a successful API response, display a success message to the user (e.g., \"Your password has been reset successfully. You can now log in with your new password.\").\n    *   Redirect the user to the login page (Task 16).\n    *   In case of API errors (e.g., invalid/expired token, server error), display appropriate and user-friendly error messages on the page.\n6.  **Component Structure**: It's recommended to create a dedicated client component (e.g., `ResetPasswordForm.tsx`) to encapsulate the form logic, state management (e.g., using `useState` or `react-hook-form`), validation, and API call handling. The page component (`app/reset-password/[token]/page.tsx`) would then import and render this form component.",
        "testStrategy": "1.  **UI Rendering and Token Handling**: \n    *   Navigate to a URL like `/reset-password/test-token`.\n    *   Verify that the page renders correctly, displaying input fields for 'New Password' and 'Confirm New Password', and a 'Reset Password' button.\n    *   Ensure the `test-token` is correctly captured by the page/form component.\n2.  **Client-Side Validation**: \n    *   Attempt to submit the form with empty password fields. Verify that appropriate client-side validation messages are displayed.\n    *   Enter a password shorter than the minimum requirement in the 'New Password' field. Verify the validation error.\n    *   Enter a valid 'New Password' but a different password in 'Confirm New Password'. Verify the mismatch error.\n3.  **Successful Password Reset Scenario**: \n    *   Prerequisite: Ensure the Password Reset API (Task 22) is functional. Manually generate or use a valid, non-expired password reset token for a test user.\n    *   Navigate to `/reset-password/[valid-token]` (replace `[valid-token]` with the actual token).\n    *   Enter a new, valid password in both fields and submit the form.\n    *   **Expected**: A success message is displayed, and the user is redirected to the login page.\n    *   **Verification**: Attempt to log in as the test user with the newly set password.\n4.  **Invalid or Expired Token Scenario**: \n    *   Navigate to `/reset-password/invalid-or-expired-token` (using a token known to be invalid or expired for testing with the API from Task 22).\n    *   Enter valid passwords in the form and submit.\n    *   **Expected**: An appropriate error message (e.g., \"Invalid or expired token. Please request a new password reset link.\") is displayed on the page, originating from the API response.\n5.  **API Error Handling (General)**: \n    *   If possible, simulate other API errors (e.g., server unavailable) when the form is submitted.\n    *   Verify that generic, user-friendly error messages are displayed on the page, preventing raw error exposure.",
        "status": "done",
        "dependencies": [
          14,
          5,
          22
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Mejorar la Interfaz y Estructura de la Página de Inicio",
        "description": "Rediseñar la página de inicio (`/`) para incluir un encabezado con acceso al login, un título principal, una sección de tarjetas informativas y un pie de página, creando una bienvenida moderna y funcional para el usuario.",
        "details": "La implementación se centrará en el archivo `app/page.tsx`. 1. **Crear Encabezado (Header)**: Implementar un componente de encabezado en la parte superior de la página. Debe mostrar el título 'Multiplataforma - DIAD' y un botón o enlace 'Login' que redirija a la página `/login`. Utilizar componentes de `shadcn/ui` para consistencia visual. 2. **Sección de Tarjetas (Cards)**: Debajo del contenido principal, crear una sección que contenga tres tarjetas dispuestas horizontalmente (en escritorio) y verticalmente (en móvil). Utilizar el componente `Card` de `shadcn/ui`. Los títulos de las tarjetas serán: 'Carga archivos', 'Ingresa tus datos' y 'Revisa la documentación'. Añadir un breve texto descriptivo a cada una. 3. **Pie de Página (Footer)**: Añadir un componente de pie de página simple en la parte inferior que contenga el texto 'DIAD - 2025'. 4. **Estilo y Responsividad**: Utilizar TailwindCSS para asegurar que el diseño sea moderno, limpio y completamente responsivo en dispositivos de escritorio y móviles.",
        "testStrategy": "1. **Verificación del Encabezado**: Navegar a la ruta raíz (`/`). Confirmar que el encabezado se muestra correctamente con el título 'Multiplataforma - DIAD'. Hacer clic en el botón 'Login' y verificar que redirige a la página `/login`. 2. **Verificación de las Tarjetas**: Desplazarse hacia abajo y confirmar la presencia de las tres tarjetas con sus respectivos títulos ('Carga archivos', 'Ingresa tus datos', 'Revisa la documentación'). 3. **Verificación del Pie de Página**: Asegurarse de que el pie de página es visible en la parte inferior de la página con el texto 'DIAD - 2025'. 4. **Pruebas de Responsividad**: Usar las herramientas de desarrollador del navegador para simular diferentes tamaños de pantalla (móvil, tableta, escritorio). Verificar que el layout se adapta correctamente, especialmente la disposición de las tarjetas y el menú de navegación.",
        "status": "done",
        "dependencies": [
          1,
          14
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear el Componente de Encabezado (Header)",
            "description": "Implementar un componente de encabezado reutilizable para la parte superior de la página. Este componente mostrará el título de la aplicación y un botón de inicio de sesión.",
            "dependencies": [],
            "details": "Crea un nuevo archivo, por ejemplo, en `components/layout/Header.tsx`. Dentro, define un componente que renderice una etiqueta `<header>`. Utiliza un `<h2>` para el título 'Multiplataforma - DIAD' y un componente `<Button>` de `shadcn/ui` con el texto 'Login'. Envuelve el botón en un componente `<Link>` de Next.js que apunte a `/login`. Usa Flexbox (`flex justify-between items-center`) para alinear los elementos. Finalmente, importa y renderiza este componente en la parte superior de `app/page.tsx`.",
            "status": "done",
            "testStrategy": "Verificar que el encabezado se renderiza correctamente, que el título es visible y que el botón 'Login' redirige a la ruta `/login` al hacer clic."
          },
          {
            "id": 2,
            "title": "Estructurar el Contenido Principal y Añadir Título de Bienvenida",
            "description": "Definir la estructura principal de la página de inicio, justo debajo del encabezado, e incluir un título principal H1 que sirva como bienvenida al usuario.",
            "dependencies": [],
            "details": "En `app/page.tsx`, debajo del componente `Header`, añade una etiqueta `<main>` que envuelva el resto del contenido de la página. Dentro de `<main>`, el primer elemento debe ser un `<h1>` con un texto como \"Bienvenido a la Plataforma de Análisis\". Utiliza clases de TailwindCSS para centrar el texto, aumentar su tamaño (`text-4xl`, `font-bold`) y añadir margen superior e inferior (`my-8`).",
            "status": "done",
            "testStrategy": "Comprobar que el título H1 aparece debajo del encabezado con el estilo y espaciado correctos."
          },
          {
            "id": 3,
            "title": "Implementar la Sección de Tarjetas Informativas",
            "description": "Desarrollar la sección que muestra tres tarjetas con información clave sobre las funcionalidades de la aplicación, utilizando los componentes de `shadcn/ui`.",
            "dependencies": [],
            "details": "Dentro de la etiqueta `<main>` en `app/page.tsx`, después del título H1, crea un `<div>` que funcionará como contenedor para las tarjetas. Dentro de este div, implementa tres componentes `<Card>` de `shadcn/ui`. Cada tarjeta debe contener un `<CardHeader>` con un `<CardTitle>` ('Carga archivos', 'Ingresa tus datos', 'Revisa la documentación') y un `<CardContent>` con un párrafo descriptivo breve para cada una.",
            "status": "done",
            "testStrategy": "Verificar que las tres tarjetas se renderizan con sus respectivos títulos y textos descriptivos."
          },
          {
            "id": 4,
            "title": "Aplicar Diseño Responsivo a la Página y las Tarjetas",
            "description": "Asegurar que toda la página, y en especial la sección de tarjetas, se visualice correctamente tanto en dispositivos móviles como en escritorios, ajustando su disposición de vertical a horizontal.",
            "dependencies": [],
            "details": "Modifica el `<div>` contenedor de las tarjetas. Aplica clases de TailwindCSS para establecer un layout de Grid: `grid grid-cols-1 md:grid-cols-3 gap-4`. Esto hará que las tarjetas se apilen verticalmente en pantallas pequeñas (`grid-cols-1`) y se muestren en tres columnas en pantallas medianas y grandes (`md:grid-cols-3`). El `gap-4` añadirá espacio entre ellas. Revisa el layout general de la página para asegurar que todos los elementos se ajustan correctamente.",
            "status": "done",
            "testStrategy": "Usar las herramientas de desarrollador del navegador para simular diferentes tamaños de pantalla (móvil, tablet, escritorio) y confirmar que el layout se adapta como se espera, especialmente la disposición de las tarjetas."
          },
          {
            "id": 5,
            "title": "Crear e Integrar el Pie de Página (Footer)",
            "description": "Implementar un componente de pie de página simple y añadirlo al final de la estructura de la página de inicio para completar el diseño.",
            "dependencies": [],
            "details": "Crea un nuevo componente, por ejemplo, en `components/layout/Footer.tsx`. Este componente debe renderizar una etiqueta `<footer>`. Dentro, añade un `<p>` con el texto 'DIAD - 2025'. Aplica clases de TailwindCSS para añadir padding (`py-4`), un borde superior (`border-t`) y centrar el texto (`text-center`). Importa y renderiza este componente al final del layout en `app/page.tsx`, después de la etiqueta `<main>`.",
            "status": "done",
            "testStrategy": "Verificar que el pie de página aparece en la parte inferior de la página con el texto y estilo correctos, y que permanece en la parte inferior independientemente del contenido."
          }
        ]
      },
      {
        "id": 25,
        "title": "Implementar Funcionalidades de Gestión de Usuarios en Panel de Administración",
        "description": "Crear una sección de administración para gestionar usuarios, incluyendo la importación masiva desde CSV, un listado con filtros y paginación, y la capacidad de modificar roles de usuario.",
        "details": "Esta tarea se divide en tres funcionalidades principales dentro de un nuevo panel de administración en la ruta `/admin/users`. 1. **Importación de Usuarios desde CSV**: Crear una página (`/admin/users/import`) con un formulario para subir archivos CSV. Implementar un endpoint de API (`/api/admin/users/import`) que utilice `papaparse` para procesar el archivo. Validar cada fila con Zod (email, nombre, rol) y usar `prisma.user.createMany()` para la inserción masiva, omitiendo duplicados. La API debe devolver un resumen de la operación (usuarios creados, errores). 2. **Listado de Usuarios**: En la página principal `/admin/users`, implementar una tabla (usando `shadcn/ui`) para mostrar los usuarios con paginación y filtros. Crear un endpoint de API (`/api/admin/users`) que acepte parámetros de consulta para filtrar por nombre/email/rol y para la paginación (usando `skip` y `take` de Prisma). 3. **Modificación de Rol**: En la tabla de usuarios, añadir un control (ej. un dropdown) para cambiar el rol de un usuario. Este control llamará a un endpoint de API (`PATCH /api/admin/users/[userId]`) que actualizará el rol del usuario en la base de datos. Es crucial actualizar el `middleware.ts` (de la Tarea 17) para proteger todas las rutas `/admin/*` y verificar que el usuario autenticado tenga el rol de 'ADMIN'.",
        "testStrategy": "1. **Seguridad de Rutas**: Intentar acceder a `/admin/users` sin iniciar sesión y verificar la redirección al login. Iniciar sesión como un usuario normal y verificar que el acceso es denegado. Iniciar sesión como administrador y verificar que el acceso es concedido. 2. **Importación CSV**: Subir un CSV válido y verificar que los nuevos usuarios aparecen en la base de datos y en el listado. Subir un CSV con datos inválidos (emails duplicados, formatos incorrectos) y verificar que se muestra un informe de errores preciso y que solo los datos válidos fueron procesados. 3. **Listado y Filtros**: Navegar a `/admin/users` y confirmar que la tabla se carga con la primera página de usuarios. Probar los controles de paginación. Usar los campos de filtro para buscar por email y rol, y verificar que la tabla se actualiza correctamente. 4. **Cambio de Rol**: En el listado, cambiar el rol de un usuario de 'USER' a 'ADMIN'. Verificar que el cambio se refleja en la base de datos. Iniciar sesión con la cuenta de ese usuario para confirmar que ahora tiene acceso a las rutas de administrador.",
        "status": "done",
        "dependencies": [
          17,
          7
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Proteger Rutas de Administración con Middleware",
            "description": "Actualizar el archivo `middleware.ts` para interceptar todas las peticiones a `/admin/*` y verificar que el usuario autenticado tenga el rol 'ADMIN'.",
            "dependencies": [],
            "details": "Modificar la función `middleware` en `middleware.ts`. Usar `next-auth` para obtener la sesión del usuario. Si la ruta coincide con `/admin/:path*` y el `session.user.role` no es 'ADMIN', redirigir a una página de no autorizado o a la página de inicio. Esta es una dependencia crítica para todas las demás tareas de administración.\n<info added on 2025-08-05T02:57:59.806Z>\nTarea completada exitosamente. Se corrigió el middleware.ts para proteger correctamente las rutas de administración:\n\n1. Se identificó que el middleware ya tenía la lógica de protección implementada:\n   - Detecta rutas /admin/* y /api/admin/* (línea 34)\n   - Verifica autenticación y rol de usuario (líneas 41-44)\n   - Redirige usuarios no autorizados a la página de inicio\n\n2. Se corrigió un problema crítico de mayúsculas/minúsculas:\n   - En el esquema de Prisma los roles son: 'user' y 'admin' (minúsculas).\n   - En el middleware se verificaba userRole !== \"ADMIN\" (mayúsculas).\n   - Se cambió a userRole !== \"admin\" para mantener la consistencia.\n\n3. Verificación funcional:\n   - El middleware ahora bloquea correctamente el acceso a las rutas de administración.\n   - Solo los usuarios con rol 'admin' pueden acceder a /admin/* y /api/admin/*.\n   - Los usuarios no autenticados son redirigidos a /login.\n   - Los usuarios autenticados sin rol de administrador son redirigidos a /.\n\nLa protección de rutas de administración está completamente funcional y lista para las siguientes subtareas del panel de administración.\n</info added on 2025-08-05T02:57:59.806Z>",
            "status": "done",
            "testStrategy": "Intentar acceder a `/admin/users` como usuario no autenticado (debería redirigir a login), como usuario sin rol 'ADMIN' (debería redirigir o mostrar error 403), y como usuario 'ADMIN' (debería permitir el acceso)."
          },
          {
            "id": 2,
            "title": "Crear Layout y Navegación del Panel de Administración",
            "description": "Establecer la estructura visual base para la sección de administración, incluyendo un layout persistente y enlaces de navegación.",
            "dependencies": [
              1
            ],
            "details": "Crear un nuevo componente de layout para las rutas `/admin/*`. Este layout debe incluir un encabezado o una barra lateral con enlaces de navegación, como 'Dashboard' y 'Gestión de Usuarios' (apuntando a `/admin/users`). Usar componentes de `shadcn/ui` para la estructura.\n<info added on 2025-08-05T03:40:43.411Z>\nArchivos creados/modificados:\n1. Creado `app/(protected)/admin/layout.tsx` - Layout persistente para todas las rutas admin con:\n   - Header con título \"Panel de Administración\", badge \"Admin\" y botón logout\n   - Sidebar de navegación con enlaces a Dashboard, Gestión de Usuarios y Configuración\n   - Diseño responsivo usando componentes shadcn/ui (Button, Badge)\n   - Íconos de Lucide React para mejor UX\n\n2. Actualizado `app/(protected)/admin/page.tsx` - Dashboard principal con:\n   - Cards de estadísticas para Total Usuarios, Verificados, Pendientes y Administradores\n   - Diseño moderno con grid responsivo\n   - Placeholders preparados para futuras APIs\n   - Componentes Card de shadcn/ui\n\nDependencias instaladas:\n- `npx shadcn add card` - Para las tarjetas de estadísticas\n- `npx shadcn add badge` - Para el indicador de rol admin\n\nEstructura implementada:\n- Header fijo con información de usuario y logout\n- Sidebar de navegación con 3 enlaces principales\n- Área de contenido principal responsive\n- Diseño profesional con Tailwind CSS y shadcn/ui\n\nVerificaciones:\n- ✅ Lint: Sin errores\n- ✅ Componentes funcionan correctamente\n- ✅ Layout se aplica a todas las rutas `/admin/*`\n- ✅ Navegación lista para futuras páginas\n</info added on 2025-08-05T03:40:43.411Z>\n<info added on 2025-08-05T04:06:27.181Z>\nProblema de middleware resuelto exitosamente.\n\nProblema identificado: El middleware estaba usando `NextAuth(authConfig)` que no incluía los callbacks necesarios para el campo `role` en la sesión.\n\nSolución implementada:\n1. Se cambió el middleware para usar `import { auth } from \"@/auth\"` en lugar de `NextAuth(authConfig)`.\n2. Esto asegura que el middleware use la configuración completa de NextAuth con todos los callbacks.\n\nResultado: El panel de administración ahora es accesible para usuarios con rol `admin`. La protección de rutas funciona correctamente:\n- Usuarios no autenticados son redirigidos a `/login`.\n- Usuarios sin rol admin son redirigidos a `/`.\n- Usuarios con rol admin tienen acceso permitido a `/admin/*`.\n\nEl layout y navegación del panel admin están completamente funcionales.\n</info added on 2025-08-05T04:06:27.181Z>",
            "status": "done",
            "testStrategy": "Navegar a `/admin/users` y verificar que el layout de administración se renderiza correctamente con los enlaces de navegación visibles y funcionales."
          },
          {
            "id": 3,
            "title": "Crear API para Listado Paginado de Usuarios",
            "description": "Implementar el endpoint `GET /api/admin/users` que devuelve una lista de usuarios con soporte para paginación.",
            "dependencies": [
              1
            ],
            "details": "Crear un nuevo `route.ts` en `app/api/admin/users`. La función `GET` debe aceptar los parámetros de consulta `page` y `limit`. Calcular `skip` (`(page - 1) * limit`) y `take` (`limit`). Usar `prisma.user.findMany({ skip, take })` y `prisma.user.count()` para obtener los datos y el total de usuarios. Devolver los usuarios y la información de paginación (total de páginas, total de usuarios).\n<info added on 2025-08-12T16:40:59.486Z>\nImplementación completada exitosamente. El endpoint GET /api/admin/users se ha implementado con las siguientes características:\n- Autenticación y autorización para verificar que el usuario esté autenticado y tenga el rol 'admin'.\n- Acepta parámetros de consulta 'page' (por defecto 1) y 'limit' (por defecto 10, máximo 100), con validación para asegurar que los valores estén en un rango válido.\n- Utiliza Promise.all para ejecutar en paralelo la consulta de usuarios y el conteo total, mejorando la eficiencia.\n- Los usuarios se devuelven ordenados por fecha de creación descendente (más recientes primero).\n- La respuesta incluye una metadata de paginación completa: currentPage, totalPages, totalUsers, limit, hasNextPage, y hasPreviousPage.\nSe realizaron pruebas exitosas de lint, lógica de paginación, estructura de respuesta, middleware de autenticación, validación de parámetros y casos de borde. El endpoint está listo para ser consumido por el frontend.\n</info added on 2025-08-12T16:40:59.486Z>",
            "status": "done",
            "testStrategy": "Realizar peticiones a `/api/admin/users?page=1&limit=10` y `/api/admin/users?page=2&limit=10` y verificar que se devuelven los conjuntos de datos correctos y la metadata de paginación."
          },
          {
            "id": 4,
            "title": "Implementar Tabla de Usuarios en el Frontend",
            "description": "Desarrollar la interfaz de usuario en `/admin/users` para mostrar la lista de usuarios en una tabla.",
            "dependencies": [
              2,
              3
            ],
            "details": "Crear la página `/admin/users/page.tsx`. Utilizar los componentes `Table`, `TableHeader`, `TableBody`, etc., de `shadcn/ui`. Realizar una llamada al endpoint `/api/admin/users` para obtener los datos y renderizarlos en la tabla. Las columnas deben incluir como mínimo: Nombre, Email y Rol.",
            "status": "done",
            "testStrategy": "Verificar que la página `/admin/users` carga y muestra correctamente la primera página de usuarios obtenida de la API en la tabla."
          },
          {
            "id": 5,
            "title": "Añadir Controles de Paginación a la Tabla de Usuarios",
            "description": "Integrar componentes de paginación en la interfaz de la tabla de usuarios para permitir la navegación entre páginas.",
            "dependencies": [
              4
            ],
            "details": "En la página `/admin/users`, añadir los componentes `Pagination` de `shadcn/ui` debajo de la tabla. Conectar los botones 'Siguiente', 'Anterior' y los números de página para que actualicen el estado de la página actual, realicen una nueva llamada a la API con el parámetro `page` correspondiente y refresquen los datos de la tabla.",
            "status": "done",
            "testStrategy": "Hacer clic en los botones de paginación y verificar que la tabla se actualiza con los usuarios de la página correspondiente."
          },
          {
            "id": 6,
            "title": "Extender API de Usuarios con Lógica de Filtrado",
            "description": "Mejorar el endpoint `GET /api/admin/users` para que admita filtrado por nombre, email y rol.",
            "dependencies": [
              3
            ],
            "details": "Modificar la función `GET` en `app/api/admin/users/route.ts`. Leer los parámetros de consulta opcionales `search` (para nombre/email) y `role`. Construir dinámicamente la cláusula `where` de Prisma para incluir condiciones `contains` para el `search` y `equals` para el `role` si los parámetros están presentes.",
            "status": "done",
            "testStrategy": "Realizar peticiones como `/api/admin/users?search=john` y `/api/admin/users?role=USER` y verificar que la API devuelve solo los usuarios que coinciden con los filtros."
          },
          {
            "id": 7,
            "title": "Implementar Controles de Filtro en la Interfaz de Usuarios",
            "description": "Añadir campos de entrada en la página de listado de usuarios para permitir al administrador filtrar los resultados.",
            "dependencies": [
              5,
              6
            ],
            "details": "En la página `/admin/users`, añadir un componente `Input` de `shadcn/ui` para la búsqueda por texto (nombre/email) y un `Select` o `DropdownMenu` para filtrar por rol. Al cambiar el valor de estos controles, se debe realizar una nueva petición a la API con los parámetros `search` y/o `role` y actualizar la tabla.",
            "status": "done",
            "testStrategy": "Escribir en el campo de búsqueda y seleccionar un rol en el dropdown. Verificar que la lista de usuarios en la tabla se actualiza para reflejar los filtros aplicados."
          },
          {
            "id": 8,
            "title": "Crear API para Modificar Rol de Usuario",
            "description": "Implementar el endpoint `PATCH /api/admin/users/[userId]` para actualizar el rol de un usuario específico.",
            "dependencies": [
              1
            ],
            "details": "Crear un `route.ts` en `app/api/admin/users/[userId]`. La función `PATCH` debe leer el `userId` de los parámetros de la ruta y el nuevo `role` del cuerpo de la petición. Validar el rol entrante. Usar `prisma.user.update({ where: { id: userId }, data: { role } })` para actualizar el registro en la base de datos. Devolver el usuario actualizado.\n<info added on 2025-08-12T17:10:02.287Z>\nImplementation completed successfully. The PATCH endpoint at /api/admin/users/[userId] was created to modify user roles. A new Zod schema, `updateUserRoleSchema`, was added to `lib/zod.ts` for validating the role (`user` or `admin`). The implementation includes authentication and authorization to ensure only admins can perform the update. A security measure was added to prevent an admin from removing their own admin role. The endpoint handles multiple error cases, including 401 (unauthorized), 400 (invalid input), 403 (self-demotion attempt), 404 (user not found), and 500 (server error). Successful requests return a structured JSON response with the updated user. The endpoint is fully tested and functional.\n</info added on 2025-08-12T17:10:02.287Z>",
            "status": "done",
            "testStrategy": "Enviar una petición PATCH a `/api/admin/users/some-id` con `{\"role\": \"ADMIN\"}` en el cuerpo y verificar que la base de datos se actualiza y la API devuelve el usuario con el nuevo rol."
          },
          {
            "id": 9,
            "title": "Añadir Control para Cambiar Rol en la Tabla",
            "description": "Integrar un control en cada fila de la tabla de usuarios para permitir la modificación directa del rol.",
            "dependencies": [
              7,
              8
            ],
            "details": "En el componente de la tabla de usuarios, añadir una nueva columna 'Acciones'. Dentro de esta columna, para cada fila, renderizar un componente `Select` o `DropdownMenu` de `shadcn/ui` con los roles disponibles. Al seleccionar un nuevo rol, se debe llamar al endpoint `PATCH /api/admin/users/[userId]` con el ID del usuario y el nuevo rol. Actualizar la UI tras una respuesta exitosa.",
            "status": "done",
            "testStrategy": "En la lista de usuarios, cambiar el rol de un usuario usando el nuevo control. Refrescar la página y verificar que el cambio de rol persiste."
          },
          {
            "id": 10,
            "title": "Crear API para Importación Masiva de Usuarios desde CSV",
            "description": "Implementar el endpoint `POST /api/admin/users/import` que procesa un archivo CSV subido.",
            "dependencies": [
              1
            ],
            "details": "Crear un `route.ts` en `app/api/admin/users/import`. La función `POST` debe manejar una petición `multipart/form-data`. Usar una librería como `papaparse` para parsear el contenido del archivo CSV a un array de objetos JSON. La API debe estar preparada para el siguiente paso de validación e inserción.",
            "status": "done",
            "testStrategy": "Enviar un archivo CSV a través de una herramienta como Postman al endpoint y verificar que la API puede leer y parsear el contenido correctamente sin errores."
          },
          {
            "id": 11,
            "title": "Implementar Validación y Lógica de Inserción para Importación CSV",
            "description": "Añadir validación de datos con Zod y la inserción en base de datos al endpoint de importación.",
            "dependencies": [
              10
            ],
            "details": "Dentro del endpoint `POST /api/admin/users/import`, después de parsear el CSV, iterar sobre cada fila. Usar un esquema de Zod para validar que cada registro tenga `email` (formato válido), `name` (string no vacío) y `role` (enum válido). Usar `prisma.user.createMany({ data: validUsers, skipDuplicates: true })` para insertar los usuarios válidos. Devolver un resumen JSON: `{ created: X, skipped: Y, errors: [...] }`.",
            "status": "done",
            "testStrategy": "Subir un CSV con datos válidos, duplicados y erróneos. Verificar que la respuesta de la API refleja correctamente el número de usuarios creados, omitidos y los errores de validación específicos."
          },
          {
            "id": 12,
            "title": "Crear Página de Frontend para Subir Archivo CSV",
            "description": "Desarrollar la interfaz en `/admin/users/import` que permita a los administradores subir un archivo CSV.",
            "dependencies": [
              2,
              11
            ],
            "details": "Crear la página `/admin/users/import/page.tsx`. Usar componentes de `shadcn/ui` para crear un formulario con un campo de subida de archivo (`Input type='file'`) y un botón de envío. Al enviar el formulario, realizar una petición `POST` al endpoint `/api/admin/users/import` con el archivo. Mostrar un mensaje de estado (cargando, éxito, error) y presentar el resumen de la operación devuelto por la API.",
            "status": "done",
            "testStrategy": "Navegar a `/admin/users/import`, seleccionar un archivo CSV y subirlo. Verificar que se muestra un feedback visual durante la subida y que el resumen de la operación (creados, errores) se muestra al usuario después."
          }
        ]
      },
      {
        "id": 26,
        "title": "Implement Statistics Section in Admin Dashboard",
        "description": "Develop the main admin dashboard page to display key user statistics via summary cards and a registration trend chart. This will provide administrators with a quick overview of platform activity.",
        "details": "This task involves creating a new API endpoint to aggregate user statistics and a new frontend page within the admin panel to display them. 1. **Backend API Endpoint**: Create a new protected API route at `/api/admin/stats`. This route should only be accessible to users with the 'ADMIN' role. The endpoint will query the database using Prisma to calculate the following metrics: Total Users (`prisma.user.count()`), New Users Today (`prisma.user.count({ where: { createdAt: ... } })`), Total Admins (`prisma.user.count({ where: { role: 'ADMIN' } })`), and Active Users (e.g., distinct users with a session in the last 30 days). For the 7-day registration trend, the endpoint must return an array of objects, each containing a date and the count of users registered on that date for the past week. 2. **Frontend Implementation**: Create a new page at `/admin/dashboard`. This page will fetch data from the `/api/admin/stats` endpoint. Use a data fetching library like SWR or React Query for client-side fetching, including loading and error states. 3. **UI Components**: Develop a reusable `StatCard` component to display each key metric. For the registration trend, install and use a charting library like 'recharts' (`npm install recharts`) to create a line or bar chart visualizing the 7-day data.",
        "testStrategy": "1. **API Security**: Attempt to access `/api/admin/stats` as a logged-out user and as a logged-in non-admin user. Both attempts should result in a 401 Unauthorized or 403 Forbidden error. Accessing the endpoint as an admin should return a 200 OK response with the statistics payload. 2. **API Data Accuracy**: Manually add/modify users in the database with various roles and `createdAt` timestamps. Call the API and verify that all returned metrics (total users, new users today, total admins) and the 7-day trend data are accurate. 3. **Frontend Verification**: Log in as an admin and navigate to the `/admin/dashboard` page. Verify that all statistic cards and the registration chart render correctly with the data from the API. Confirm that a loading state is visible during the initial data fetch and that an error message is displayed if the API call fails.",
        "status": "done",
        "dependencies": [
          7,
          8,
          17,
          25
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create and Secure the Admin Statistics API Endpoint",
            "description": "Set up the basic file structure for the `/api/admin/stats` API route and implement role-based access control to ensure only users with the 'ADMIN' role can access it. This foundational step prevents unauthorized data access before implementing the data logic.",
            "dependencies": [],
            "details": "Create a new route handler at `app/api/admin/stats/route.ts`. Inside the `GET` handler, use `getServerSession` from `next-auth` to retrieve the user's session. Check if `session.user.role` is equal to 'ADMIN'. If the user is not an admin or is not logged in, return a `NextResponse` with a 403 Forbidden status. If they are an admin, return a placeholder JSON object with a 200 OK status for now, e.g., `{ \"message\": \"Access granted\" }`.",
            "status": "done",
            "testStrategy": "1. Attempt to access `/api/admin/stats` via a tool like Postman or curl as a logged-out user (expect 401/403). 2. Log in as a regular user and attempt access (expect 403). 3. Log in as an admin and attempt access (expect 200 OK with the placeholder message)."
          },
          {
            "id": 2,
            "title": "Implement Summary Statistics Calculation in API",
            "description": "Extend the `/api/admin/stats` endpoint to calculate and return the primary summary statistics: Total Users, New Users Today, and Total Admins. This provides the data needed for the top-level summary cards.",
            "dependencies": [
              "26.1"
            ],
            "details": "In `app/api/admin/stats/route.ts`, use Prisma to perform the database queries. Calculate the start of the current day. Use `Promise.all` to execute the following queries concurrently: `prisma.user.count()`, `prisma.user.count({ where: { role: 'ADMIN' } })`, and `prisma.user.count({ where: { createdAt: { gte: startOfDay } } })`. Structure the response to return these values in a clear JSON object, e.g., `{ \"summary\": { \"totalUsers\": 150, \"newUsersToday\": 5, \"totalAdmins\": 3 } }`.",
            "status": "done",
            "testStrategy": "Call the endpoint as an admin. Verify the returned counts for total users, new users, and admins match the current state of the database. Manually add a new user via your application or database client and re-run the request to confirm the 'newUsersToday' count increments."
          },
          {
            "id": 3,
            "title": "Implement 7-Day Registration Trend Calculation in API",
            "description": "Enhance the `/api/admin/stats` endpoint to calculate and include the user registration trend for the last 7 days. This data will be used to power the registration chart.",
            "dependencies": [
              "26.2"
            ],
            "details": "In the same API route, implement logic to get user registration counts for each of the last 7 days. You can achieve this with a Prisma `groupBy` query on the `createdAt` field, filtering for records within the last 7 days. Process the results to create an array of 7 objects, one for each day, ensuring that days with zero registrations are included. The final structure should be like `[{ date: 'YYYY-MM-DD', count: 12 }, ...]`. Add this array to the API response payload under a key like `registrationTrend`.",
            "status": "done",
            "testStrategy": "Call the endpoint as an admin and inspect the `registrationTrend` array. Verify it contains exactly 7 entries, one for each of the past 7 days. Check that the counts for a few days are accurate based on the database records. Ensure a day with no new users shows a count of 0."
          },
          {
            "id": 4,
            "title": "Set Up Admin Dashboard Page with Data Fetching",
            "description": "Create the new frontend page at `/admin/dashboard` and implement client-side data fetching from the `/api/admin/stats` endpoint using SWR. This includes handling loading and error states.",
            "dependencies": [
              "26.3"
            ],
            "details": "Create the page file at `app/admin/dashboard/page.tsx`. Mark it as a client component with `'use client'`. Use the `useSWR` hook to fetch data from `/api/admin/stats`. Define a simple fetcher function for SWR. Based on the hook's return values (`data`, `error`, `isLoading`), render a loading indicator (e.g., a spinner), an error message, or the main dashboard content. Initially, you can render the fetched data using `<pre>{JSON.stringify(data, null, 2)}</pre>` to confirm it's working.",
            "status": "done",
            "testStrategy": "Navigate to `/admin/dashboard` as an admin. Verify the loading state appears briefly, followed by the raw JSON data from the API. Test the error state by temporarily renaming the API route file and reloading the page; an error message should be displayed."
          },
          {
            "id": 5,
            "title": "Create Reusable StatCard UI Component",
            "description": "Develop a reusable React component named `StatCard` to display a single statistic with a title and a value. This component will be used to display each of the summary metrics.",
            "dependencies": [],
            "details": "Create a new component file at `components/admin/StatCard.tsx`. The component should accept props for `title` (string) and `value` (string or number). Use Tailwind CSS to style it as a card with a background, padding, and distinct typography for the title and the value. The title should be smaller and less prominent than the large, bold value.",
            "status": "done",
            "testStrategy": "Use a tool like Storybook or a temporary test page to render the `StatCard` component with various static props (e.g., title='Total Users', value=1234) to ensure it displays correctly and is visually appealing."
          },
          {
            "id": 6,
            "title": "Integrate StatCards into Dashboard Page",
            "description": "Use the fetched statistics data to render multiple `StatCard` components on the `/admin/dashboard` page, creating the main summary section.",
            "dependencies": [
              "26.4",
              "26.5"
            ],
            "details": "On the `/admin/dashboard` page, once the SWR fetch is successful and `data` is available, render a grid (e.g., using CSS Grid or Flexbox). Inside the grid, render three instances of the `StatCard` component. Pass the relevant data from the API response to each card, for example: `<StatCard title=\"Total Users\" value={data.summary.totalUsers} />`, `<StatCard title=\"New Users Today\" value={data.summary.newUsersToday} />`, etc.",
            "status": "done",
            "testStrategy": "Load the dashboard page as an admin. Verify that three stat cards appear at the top of the page, displaying the correct titles and values fetched from the API. Check that the layout is responsive on different screen sizes."
          },
          {
            "id": 7,
            "title": "Create Registration Trend Chart Component",
            "description": "Install 'recharts' and create a new, dedicated component that uses it to render a line chart for displaying user registration trends over time.",
            "dependencies": [],
            "details": "First, run `npm install recharts`. Create a new component file at `components/admin/RegistrationChart.tsx`. This component should accept the `registrationTrend` data array as a prop. Inside the component, use `recharts` components like `ResponsiveContainer`, `LineChart`, `Line`, `XAxis`, `YAxis`, `CartesianGrid`, and `Tooltip` to build the chart. The `XAxis` should use the `date` key from the data, and the `Line` should use the `count` key.",
            "status": "done",
            "testStrategy": "Render the `RegistrationChart` component in Storybook or a temporary page, passing it a mock array of 7-day data. Verify that the chart renders correctly with axes, a data line, and a functional tooltip that shows the count on hover."
          },
          {
            "id": 8,
            "title": "Integrate Registration Chart into Dashboard Page",
            "description": "Add the `RegistrationChart` component to the `/admin/dashboard` page and pass the 7-day registration trend data from the API fetch to it, completing the dashboard's UI.",
            "dependencies": [
              "26.4",
              "26.7"
            ],
            "details": "On the `/admin/dashboard` page, below the grid of `StatCard`s, render the `RegistrationChart` component. Pass the `data.registrationTrend` array from the SWR fetch to the chart component's data prop. Wrap the chart in a container with a title, such as 'New Registrations (Last 7 Days)'.",
            "status": "done",
            "testStrategy": "Load the dashboard page as an admin. Verify that the line chart renders below the stat cards and accurately visualizes the registration data from the API. Hover over points on the chart to ensure the tooltip displays the correct date and user count."
          }
        ]
      },
      {
        "id": 27,
        "title": "Implement Quick Actions Section in Admin Dashboard",
        "description": "Create a 'Quick Actions' component for the main admin dashboard, providing administrators with one-click access to common tasks like exporting user data, copying an invitation link, viewing recent activity, and navigating to system settings.",
        "details": "This task involves creating a new UI component on the main admin dashboard page. 1. **Component Creation**: Develop a new React component, `QuickActions.tsx`, to be placed on the dashboard page created in Task #26. The component should display four distinct actions, likely as cards or large buttons with icons. 2. **Export User Data**: Implement a new protected API endpoint at `/api/admin/users/export`. This endpoint will use Prisma to fetch all user records (selecting fields like id, name, email, role, createdAt) and convert the data to a CSV formatted string using a library like `papaparse`. The response headers must be set to `Content-Type: text/csv` and `Content-Disposition: attachment; filename=\"users-export.csv\"` to trigger a download. The frontend button will link directly to this endpoint. 3. **Copy Invitation Link**: This is a client-side feature. The button will use the `navigator.clipboard.api` to copy a static registration link (e.g., `/register?ref=admin`) to the clipboard and display a toast notification for user feedback. 4. **View Recent Activity & Configure System**: These two actions will be simple navigation links. They should point to `/admin/activity-log` and `/admin/settings` respectively. The creation of these pages is out of scope for this task.",
        "testStrategy": "1. **UI and Security Verification**: Log in as an administrator and navigate to the main dashboard. Confirm the 'Quick Actions' section is visible and correctly rendered. Log in as a regular user and verify that the admin dashboard is inaccessible. 2. **Export Functionality**: As an admin, click the 'Export User Data' button. Verify a CSV file is downloaded. Open the file and check that its contents accurately reflect the user data in the database. Attempt to access the `/api/admin/users/export` URL directly while logged out or as a regular user and confirm access is denied with a 403 Forbidden error. 3. **Copy Link Functionality**: Click the 'Copy Invitation Link' button. Verify a success message appears. Paste the clipboard contents into a text field to ensure the correct URL has been copied. 4. **Navigation Links**: Click the 'View Recent Activity' and 'Configure System' links and verify that the browser attempts to navigate to `/admin/activity-log` and `/admin/settings` respectively.",
        "status": "done",
        "dependencies": [
          17,
          25,
          26
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `QuickActions.tsx` Component Shell and Integrate into Dashboard",
            "description": "Create the basic structure for the `QuickActions` component. This includes creating the file, setting up a container (e.g., a grid), and adding placeholder elements for the four actions. This component should then be imported and rendered on the main admin dashboard page from Task #26.",
            "dependencies": [],
            "details": "Create a new file at `components/admin/QuickActions.tsx`. Use a `div` with CSS Grid or Flexbox to lay out four placeholder child elements. Each placeholder can be a simple `div` with a title like 'Export Users'. Import this new component into the main dashboard page component (e.g., `app/admin/dashboard/page.tsx`) and render it in the appropriate location.",
            "status": "done",
            "testStrategy": "Navigate to the admin dashboard page. Verify that the 'Quick Actions' section is visible with four placeholder items."
          },
          {
            "id": 2,
            "title": "Implement Protected API Endpoint for User Data Export",
            "description": "Create a new protected API route at `/api/admin/users/export` that fetches all user data using Prisma, converts it to a CSV string, and returns it as a downloadable file.",
            "dependencies": [],
            "details": "Create a new route handler at `app/api/admin/users/export/route.ts`. Protect this route to ensure only authenticated admins can access it (e.g., by checking the user's session and role). Use Prisma to fetch users, selecting only necessary fields (`id`, `name`, `email`, `role`, `createdAt`). Use a library like `papaparse` to convert the JSON array to a CSV string. Set the response headers: `Content-Type: text/csv` and `Content-Disposition: attachment; filename=\"users-export.csv\"`.",
            "status": "done",
            "testStrategy": "While logged in as an admin, directly access `/api/admin/users/export` in the browser. Verify that a file named `users-export.csv` is downloaded. Open the file and confirm it contains the correct user data. Attempt to access the endpoint as a non-admin or unauthenticated user and verify access is denied."
          },
          {
            "id": 3,
            "title": "Implement 'Export User Data' Action on the Frontend",
            "description": "Replace the 'Export User Data' placeholder in the `QuickActions` component with a functional link or button that directs the user to the export API endpoint, triggering a file download.",
            "dependencies": [
              "27.1",
              "27.2"
            ],
            "details": "In `QuickActions.tsx`, replace the placeholder for the export action with an `<a>` tag. Set the `href` attribute to `'/api/admin/users/export'`. Style this link to look like a button or action card. Add an appropriate icon (e.g., a download icon).",
            "status": "done",
            "testStrategy": "As an admin, navigate to the dashboard and click the 'Export User Data' button. Verify that the CSV file download is initiated."
          },
          {
            "id": 4,
            "title": "Implement 'Copy Invitation Link' Client-Side Action",
            "description": "Implement the functionality for the 'Copy Invitation Link' button. This action will be purely client-side, using the browser's Clipboard API to copy a predefined link and showing a toast notification on success.",
            "dependencies": [
              "27.1"
            ],
            "details": "In `QuickActions.tsx`, replace the placeholder for this action with a `<button>`. Create an `onClick` handler function. Inside the handler, use `navigator.clipboard.writeText('/register?ref=admin')`. After the promise resolves, trigger a toast notification (using a library like `react-hot-toast` or similar) to inform the user 'Invitation link copied!'. Add a copy icon to the button.",
            "status": "done",
            "testStrategy": "Click the 'Copy Invitation Link' button. Verify that a success notification appears. Paste the content into a text editor to confirm the correct link (`/register?ref=admin`) was copied."
          },
          {
            "id": 5,
            "title": "Implement Navigation Links for 'View Recent Activity' and 'System Settings'",
            "description": "Replace the remaining two placeholders with navigation links that direct the administrator to the 'Recent Activity' and 'System Settings' pages.",
            "dependencies": [
              "27.1"
            ],
            "details": "In `QuickActions.tsx`, use the Next.js `<Link>` component for these two actions. The 'View Recent Activity' link should have an `href` of `'/admin/activity-log'`. The 'Configure System' link should have an `href` of `'/admin/settings'`. Add appropriate icons for each link (e.g., a list/log icon and a gear/settings icon).",
            "status": "done",
            "testStrategy": "Click the 'View Recent Activity' link and verify the URL changes to `/admin/activity-log`. Go back and click the 'Configure System' link and verify the URL changes to `/admin/settings`."
          },
          {
            "id": 6,
            "title": "Apply Final Styling and Icons to the Quick Actions Component",
            "description": "Apply consistent styling to all four action items to make them visually appealing and cohesive with the dashboard's design. Ensure each action has a clear title and a relevant icon.",
            "dependencies": [
              "27.3",
              "27.4",
              "27.5"
            ],
            "details": "Use a CSS framework like Tailwind CSS or a component library to style the action items as cards or large buttons. Ensure they have hover and focus states for better UX. Use a consistent icon set (e.g., from `lucide-react` or `heroicons`). The final component should be responsive and look good on different screen sizes.",
            "status": "done",
            "testStrategy": "Visually inspect the Quick Actions section on the dashboard. Confirm all four actions are styled consistently, have icons, are aligned correctly, and respond well to different viewport sizes. Check hover and active states for each action."
          }
        ]
      },
      {
        "id": 28,
        "title": "Implement Role-Based Post-Login Redirection",
        "description": "Update the authentication logic to redirect users to different pages based on their role after a successful login. Administrators will be sent to the admin dashboard, while regular users will be directed to their personal dashboard.",
        "details": "The primary goal is to create a centralized redirection logic that executes immediately after a user authenticates. This will be achieved by creating a dedicated post-login handler page. 1. **Ensure Role in Session**: Verify that the `[...nextauth]` configuration file correctly includes the user's `role` in the session token. The `jwt` callback should add the role from the user object to the token, and the `session` callback should expose the role from the token to the client-side session object. 2. **Create Post-Login Handler Page**: Create a new client component at `app/auth/post-login/page.tsx`. This page will act as a router. 3. **Implement Redirection Logic**: Inside the `post-login` component, use the `useSession` hook from `next-auth/react` and the `useRouter` hook from `next/navigation`. Use a `useEffect` hook to check the session status. If the status is 'loading', display a loading indicator. Once the status is 'authenticated', inspect the `session.user.role` property. If the role is 'ADMIN', use `router.replace('/admin')`. For any other role (e.g., 'USER'), use `router.replace('/dashboard')`. If the user is unauthenticated, redirect them back to `/login`. 4. **Update Login Flow**: Modify all `signIn()` function calls (e.g., in the login form) to specify the new handler page as the destination, for example: `signIn('credentials', { ...data, callbackUrl: '/auth/post-login' })`.",
        "testStrategy": "1. **Admin Login Test**: Log out completely. Navigate to the login page and sign in using an account with the 'ADMIN' role. Verify that you are automatically and correctly redirected to the admin dashboard (`/admin`). 2. **Regular User Login Test**: Log out completely. Navigate to the login page and sign in using a standard user account. Verify that you are automatically redirected to the main user dashboard (`/dashboard`). 3. **Manual Navigation Check**: After being logged in as a regular user, attempt to manually navigate to `/admin`. Verify that access is denied (as per existing middleware rules). 4. **Callback URL Check**: Inspect the network request during login to ensure the `callbackUrl` is being set to `/auth/post-login` correctly.",
        "status": "done",
        "dependencies": [
          18,
          26
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Update NextAuth.js Configuration to Include User Role in Session",
            "description": "Modify the NextAuth.js configuration to ensure the user's role is available in the client-side session object. This involves updating the `jwt` and `session` callbacks to pass the role from the user database model to the session token and then to the client.",
            "dependencies": [],
            "details": "1. Open the NextAuth.js configuration file (e.g., `app/api/auth/[...nextauth]/route.ts`).\n2. In the `callbacks` object, locate the `jwt` callback. Inside, ensure the `user.role` is added to the `token` object when the user first signs in.\n3. Locate the `session` callback. Inside, retrieve the `role` from the `token` object and assign it to `session.user.role`.\n4. Update the TypeScript types in `next-auth.d.ts` to include `role: string;` in the `User` and `Session` interfaces to ensure type safety.",
            "status": "done",
            "testStrategy": "After logging in, use browser developer tools to inspect the session object returned by the `useSession` hook in any client component. Verify that `session.user.role` exists and contains the correct value ('ADMIN' or 'USER')."
          },
          {
            "id": 2,
            "title": "Create the Post-Login Redirection Handler Page",
            "description": "Create a new client-side page component that will act as a central router after a user successfully logs in. This page will contain the redirection logic and display a loading state while processing.",
            "dependencies": [],
            "details": "1. Create a new file at `app/auth/post-login/page.tsx`.\n2. Define a React component (e.g., `PostLoginPage`) within this file.\n3. Add the `\"use client\";` directive at the top of the file.\n4. The component should render a simple loading indicator, such as a spinner or a 'Redirecting...' message, to provide user feedback.",
            "status": "done",
            "testStrategy": "Manually navigate to `/auth/post-login` in the browser. Verify that the loading state UI is displayed correctly without any errors."
          },
          {
            "id": 3,
            "title": "Implement Role-Based Redirection Logic in Handler Page",
            "description": "Add the core logic to the post-login handler page to inspect the user's session and role, then redirect them to the appropriate dashboard or back to the login page if unauthenticated.",
            "dependencies": [
              "28.1",
              "28.2"
            ],
            "details": "1. In `app/auth/post-login/page.tsx`, import and use the `useSession` hook from `next-auth/react` and the `useRouter` hook from `next/navigation`.\n2. Implement a `useEffect` hook that triggers when the session `status` changes.\n3. Inside the `useEffect`:\n   - If `status === 'authenticated'`, check `session.user.role`.\n   - If the role is 'ADMIN', call `router.replace('/admin')`.\n   - For any other role (e.g., 'USER'), call `router.replace('/dashboard')`.\n   - If `status === 'unauthenticated'`, call `router.replace('/login')` to handle cases where a user lands here without a session.",
            "status": "done",
            "testStrategy": "After logging in as an admin, manually navigate to `/auth/post-login`. Verify you are redirected to `/admin`. Log out, log in as a regular user, and manually navigate to `/auth/post-login`. Verify you are redirected to `/dashboard`."
          },
          {
            "id": 4,
            "title": "Update Login Form to Use the Post-Login Handler",
            "description": "Modify the `signIn` function calls in the application's login form to use the new post-login handler page as the `callbackUrl`, ensuring all successful logins are routed through the new redirection logic.",
            "dependencies": [
              "28.3"
            ],
            "details": "1. Locate the component containing the login form (e.g., `components/auth/LoginForm.tsx`).\n2. Find the `signIn()` function call that is executed on form submission.\n3. Add the `callbackUrl` option to the second argument of the `signIn` call, setting its value to `'/auth/post-login'`. Example: `signIn('credentials', { ...data, callbackUrl: '/auth/post-login' });`.",
            "status": "done",
            "testStrategy": "1. Log out completely. Navigate to the login page and sign in with an 'ADMIN' account. Verify you are correctly and automatically redirected to the `/admin` dashboard.\n2. Log out again. Sign in with a regular 'USER' account. Verify you are correctly and automatically redirected to the `/dashboard` page."
          }
        ]
      },
      {
        "id": 29,
        "title": "Implement User File Management System (Upload, List, Update, Delete)",
        "description": "Develop a complete file management system for authenticated users. This includes creating a dedicated UI page and the necessary API endpoints to handle file uploads, display a list of user-owned files, and allow for file renaming and deletion.",
        "details": "This task involves creating a full CRUD (Create, Read, Update, Delete) functionality for user-specific files. 1. **Database Schema**: Add a new `File` model to `prisma/schema.prisma`. It must include fields like `id`, `filename`, `storagePath`, `mimetype`, `size`, `createdAt`, and a relation to the `User` model (`userId String`, `@relation(...)`). Run `npx prisma migrate dev` to apply changes. 2. **Backend API Endpoints**: Create API routes under `app/api/files/`. All routes must be protected and verify that the user performing the action is the owner of the file. - **POST /api/files/upload**: Handle `multipart/form-data` requests. Save the uploaded file to a secure location on the server (e.g., a non-public `uploads` directory) and create a corresponding record in the `File` table, linking it to the authenticated user's ID. - **GET /api/files**: Fetch and return a list of all file records belonging to the currently authenticated user. - **PUT /api/files/[fileId]**: Handle file metadata updates, primarily renaming. It should receive a new `filename` in the request body, validate ownership, and update the database record. - **DELETE /api/files/[fileId]**: Validate ownership, then delete the physical file from the server's storage and remove its corresponding record from the database. 3. **Frontend UI**: Create a new page at `/dashboard/files`. - **File Upload Form**: Implement a form with an `<input type=\"file\">` that submits to the upload endpoint. Provide user feedback on upload progress, success, or failure. - **File List Display**: Use a data fetching hook (like SWR or React Query) to call the `GET /api/files` endpoint. Display the files in a table or grid, showing the filename, upload date, and action buttons (e.g., Rename, Delete, Download). - **Modals for Actions**: Implement modals for renaming a file (pre-filled with the current name) and for confirming deletion to prevent accidental data loss.",
        "testStrategy": "1. **Authorization & Security**: Attempt to access the `/dashboard/files` page while logged out and verify redirection to the login page. Log in as User A, upload a file, and note its ID. Log in as User B and attempt to list, update, or delete User A's file via direct API calls; verify all attempts are rejected with a 403 Forbidden or 404 Not Found error. 2. **Upload Functionality**: Upload a file (e.g., PDF, JPG). Verify it appears in the UI list, is physically present in the server's upload directory, and a corresponding record exists in the database linked to the correct user. 3. **List Functionality**: Upload multiple files. Verify all are correctly listed for the logged-in user. Log in as a different user and confirm their file list is empty or shows only their own files. 4. **Update Functionality**: Use the UI to rename a file. Verify the name changes in the list and the database record is updated. 5. **Delete Functionality**: Use the UI to delete a file. Confirm the deletion prompt appears. After confirming, verify the file is removed from the UI list, deleted from the server's file system, and its record is removed from the database.",
        "status": "done",
        "dependencies": [
          7,
          8,
          17
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Define and Migrate the `File` Model in Prisma Schema",
            "description": "Create the database schema for storing file metadata. This involves adding a `File` model to `prisma/schema.prisma` and running a migration to apply the changes to the database.",
            "dependencies": [],
            "details": "In `prisma/schema.prisma`, define a new `File` model. It must include fields: `id` (String, @id, @default(cuid())), `filename` (String), `storagePath` (String), `mimetype` (String), `size` (Int), `createdAt` (DateTime, @default(now())), and a relation to the `User` model. Add `userId String` and the relation field `user User @relation(fields: [userId], references: [id], onDelete: Cascade)`. After defining the model, run the command `npx prisma migrate dev --name add_file_model` to generate and apply the migration.",
            "status": "done",
            "testStrategy": "After migration, use a database client (like Prisma Studio) to verify that the `File` table with the correct columns and relations has been created in the database."
          },
          {
            "id": 2,
            "title": "Create API Endpoint for File Upload (POST /api/files/upload)",
            "description": "Develop a protected API route to handle multipart/form-data file uploads. The endpoint will save the file to a designated server directory and create a corresponding record in the `File` table.",
            "dependencies": [
              "29.1"
            ],
            "details": "Create the route handler at `app/api/files/upload/route.ts`. Use a library like `formidable` or handle the stream directly to process the `multipart/form-data` request. First, verify the user is authenticated using `getServerSession` from NextAuth.js. Generate a unique name for the file to avoid collisions and save it to a non-public directory (e.g., `./uploads`). After successfully saving the file, create a new entry in the `File` table using Prisma, linking it to the authenticated user's ID and storing metadata like the original filename, the new storage path, mimetype, and size. Return a 201 Created response with the new file's data.",
            "status": "done",
            "testStrategy": "Use an API client like Postman or Insomnia to send a POST request with a valid session cookie and a file in a `multipart/form-data` body. Verify that the file is saved on the server's filesystem and a corresponding record is created in the database. Test error cases like unauthenticated requests or requests without a file."
          },
          {
            "id": 3,
            "title": "Create API Endpoint to List User's Files (GET /api/files)",
            "description": "Develop a protected API route that retrieves and returns a list of all file metadata records associated with the currently authenticated user.",
            "dependencies": [
              "29.1"
            ],
            "details": "Create the route handler at `app/api/files/route.ts`. In the `GET` handler, retrieve the user's session to get their ID. Use Prisma to query the `File` table, filtering by the `userId`. The query should be `prisma.file.findMany({ where: { userId: session.user.id }, orderBy: { createdAt: 'desc' } })`. Return the resulting array of file objects as a JSON response with a 200 OK status. Ensure the route is protected and returns a 401 Unauthorized error if no session is found.",
            "status": "done",
            "testStrategy": "After uploading a few files using the endpoint from subtask 29.2, make an authenticated GET request to `/api/files`. Verify that the response is a JSON array containing the correct file records for that user. Test that an unauthenticated request receives a 401 error."
          },
          {
            "id": 4,
            "title": "Build the File Management UI Page and Display the File List",
            "description": "Create a new page at `/dashboard/files` and implement the UI to fetch and display the user's files in a table or grid format.",
            "dependencies": [
              "29.3"
            ],
            "details": "Create a new route `app/dashboard/files/page.tsx`. This should be a client component (`'use client'`). Use a data fetching library like SWR or React Query to call the `/api/files` endpoint. While data is loading, show a loading spinner. If there's an error, display an error message. Once the data is fetched, map over the array of files and render them in a table. The table should have columns for `Filename`, `Upload Date`, `Size`, and `Actions` (which will be empty for now). Use a utility function to format the date and file size for display.",
            "status": "done",
            "testStrategy": "Navigate to `/dashboard/files` while logged in. Verify that a loading state is shown initially, followed by a table displaying the files previously uploaded for the current user. Check that the page is protected by middleware and redirects to login if accessed while logged out."
          },
          {
            "id": 5,
            "title": "Implement the File Upload Form on the Frontend",
            "description": "Add a file upload form to the `/dashboard/files` page that allows users to select and upload a file. Provide feedback on the upload status.",
            "dependencies": [
              "29.2",
              "29.4"
            ],
            "details": "In the `app/dashboard/files/page.tsx` component, add a form with an `<input type=\"file\">` and a submit button. On form submission, prevent the default action and create a `FormData` object. Append the selected file to it. Use the `fetch` API or a library like `axios` to send a POST request to `/api/files/upload` with the `FormData` as the body. Implement state to track the upload progress (e.g., 'idle', 'uploading', 'success', 'error'). Disable the submit button while uploading. Display success or error messages to the user. Upon successful upload, re-fetch the file list to show the newly added file.",
            "status": "done",
            "testStrategy": "On the `/dashboard/files` page, use the new form to select and upload a file. Verify that the UI shows an 'uploading' state. After the upload completes, confirm that a success message is shown and the file list automatically updates to include the new file."
          },
          {
            "id": 6,
            "title": "Create API Endpoint for File Deletion (DELETE /api/files/[fileId])",
            "description": "Develop a protected API route that handles file deletion. It must verify that the user owns the file before deleting both the physical file from storage and its record from the database.",
            "dependencies": [
              "29.1"
            ],
            "details": "Create a dynamic route handler at `app/api/files/[fileId]/route.ts`. In the `DELETE` handler, get the `fileId` from the route parameters and the user's session. First, query the database for the file: `prisma.file.findUnique({ where: { id: fileId } })`. If the file doesn't exist or if `file.userId` does not match the session's `user.id`, return a 404 Not Found or 403 Forbidden error. If ownership is verified, use Node.js's `fs` module (`fs.promises.unlink`) to delete the physical file from the path specified in `file.storagePath`. After successfully deleting the file, delete the record from the database: `prisma.file.delete({ where: { id: fileId } })`. Return a 204 No Content response on success.",
            "status": "done",
            "testStrategy": "Using an API client, send an authenticated DELETE request to `/api/files/[fileId]` for a file owned by the user. Verify a 204 response, and confirm the file is gone from both the filesystem and the database. Attempt to delete a file owned by another user and verify a 403/404 error is returned."
          },
          {
            "id": 7,
            "title": "Create API Endpoint for File Renaming (PUT /api/files/[fileId])",
            "description": "Develop a protected API route to update a file's metadata, specifically its name. The endpoint must validate user ownership before updating the database record.",
            "dependencies": [
              "29.1"
            ],
            "details": "In the `app/api/files/[fileId]/route.ts` file, implement the `PUT` handler. It should expect a JSON body with a `filename` property. Get the `fileId` and user session. Find the file in the database and verify ownership, similar to the DELETE endpoint. If ownership is confirmed, use Prisma to update the record: `prisma.file.update({ where: { id: fileId }, data: { filename: newFilename } })`. Return the updated file object with a 200 OK status. Use Zod to validate the incoming `filename` to ensure it's a non-empty string.",
            "status": "done",
            "testStrategy": "Using an API client, send an authenticated PUT request to `/api/files/[fileId]` with `{\"filename\": \"new-name.txt\"}` in the body. Verify a 200 response containing the updated file data. Check the database to confirm the `filename` field was updated. Test for invalid input and ownership errors."
          },
          {
            "id": 8,
            "title": "Add Rename and Delete Modals and Functionality to the UI",
            "description": "Enhance the file list on the `/dashboard/files` page by adding 'Rename' and 'Delete' buttons. Implement modals for these actions to provide a good user experience and prevent accidental deletion.",
            "dependencies": [
              "29.4",
              "29.6",
              "29.7"
            ],
            "details": "In the `Actions` column of the file table in `app/dashboard/files/page.tsx`, add 'Rename' and 'Delete' buttons for each file. For 'Delete', clicking the button should open a confirmation modal asking 'Are you sure you want to delete this file?'. On confirmation, send a `DELETE` request to `/api/files/[fileId]`. For 'Rename', clicking the button should open a modal with a text input pre-filled with the current filename. On submitting the modal form, send a `PUT` request to `/api/files/[fileId]` with the new name. After either action is successful, re-fetch the file list to update the UI.",
            "status": "done",
            "testStrategy": "On the file list page, click the 'Delete' button for a file. Verify the confirmation modal appears. Confirm the deletion and check that the file is removed from the list. Click the 'Rename' button for another file. Verify the modal appears with the current name. Enter a new name, submit, and verify the filename updates in the list."
          }
        ]
      },
      {
        "id": 30,
        "title": "Create New Main Dashboard with Visual Navigation Cards",
        "description": "Develop a new main user dashboard to serve as a central navigation hub. The dashboard will feature a personalized welcome message and visual cards for key application sections, with a conditional card for administrator access.",
        "details": "This task involves replacing the simple dashboard from Task #18 with a more functional and visually appealing hub. The implementation will be in `app/dashboard/page.tsx`. Use a component library (e.g., Shadcn/ui) to create a responsive grid of `Card` components. 1. **Personalization**: Fetch the authenticated user's session data to display a welcome message, such as 'Welcome, [User Name]!'. 2. **Navigation Cards**: Create distinct cards for 'File Management', 'Profile Management', 'Settings', and 'Reports'. The 'File Management' card must link to the page created in Task #29 (`/dashboard/files`). The 'Reports' card should be styled as disabled or marked 'Coming Soon' as the functionality is not yet built. 3. **Conditional Admin Card**: Check the user's role from the session data. If the role is 'ADMIN', render an additional card titled 'Admin Panel' that links to the `/admin` dashboard created in Task #26. This card should be visually distinct to highlight its administrative nature.",
        "testStrategy": "1. **Regular User Login**: Log in as a standard user. Verify you land on the new dashboard. Confirm the personalized welcome message is correct. Check that cards for File Management, Profile Management, Settings, and Reports are visible. Crucially, verify the 'Admin Panel' card is NOT visible. Click the 'File Management' card to ensure it navigates to the correct page. 2. **Admin User Login**: Log in as an administrator. Navigate to the `/dashboard` page. Verify all standard cards are present, AND the 'Admin Panel' card is also visible. Click the 'Admin Panel' card and confirm it correctly navigates to the `/admin` dashboard. 3. **Logged-Out Access**: Attempt to access `/dashboard` directly while not authenticated and verify you are redirected to the login page. 4. **Responsiveness**: Check the dashboard layout on various screen sizes to ensure the card grid adapts properly.",
        "status": "done",
        "dependencies": [
          18,
          26,
          28,
          29
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Refactor Dashboard Page and Fetch User Session Data",
            "description": "Clear the existing content in `app/dashboard/page.tsx` from Task #18 and set up the new page structure. Implement server-side logic to fetch the authenticated user's session data, which is required for the personalized welcome message and conditional card rendering.",
            "dependencies": [],
            "details": "Convert `app/dashboard/page.tsx` to a server component. Use a server-side session utility from your authentication provider (e.g., `auth()` from NextAuth.js) to retrieve the current user's session, including their name and role. If no session exists, the middleware should handle redirection. The fetched user object will be used in subsequent subtasks.",
            "status": "done",
            "testStrategy": "Log in and navigate to `/dashboard`. Verify the page loads without errors. Add a `console.log` on the server to confirm that the user's session data (name, email, role) is being fetched correctly."
          },
          {
            "id": 2,
            "title": "Implement Personalized Welcome Message",
            "description": "Create and style a header section on the dashboard that displays a personalized welcome message using the user's name fetched from the session data.",
            "dependencies": [
              "30.1"
            ],
            "details": "In the `app/dashboard/page.tsx` component, add an `<h1>` or `<h2>` tag at the top of the page. Use the user's name from the session data obtained in subtask 30.1 to render a message like 'Welcome, [User Name]!'. Apply appropriate typography and spacing using Tailwind CSS classes.",
            "status": "done",
            "testStrategy": "Log in with a user that has a name defined in their profile. Verify the welcome message displays their correct name. Test with a user whose name is null or undefined to ensure the component handles it gracefully (e.g., displays 'Welcome!')."
          },
          {
            "id": 3,
            "title": "Create Reusable `NavigationCard` Component",
            "description": "Develop a reusable React component, `NavigationCard.tsx`, using Shadcn/ui's `Card` component. This component will accept props like `title`, `description`, `href`, `icon`, and `disabled` to standardize the appearance and behavior of all dashboard navigation cards.",
            "dependencies": [],
            "details": "Create a new component file, e.g., `components/dashboard/NavigationCard.tsx`. Use Shadcn/ui components (`Card`, `CardHeader`, `CardTitle`, `CardDescription`, `CardContent`). The component should be wrapped in a Next.js `<Link>` component if an `href` is provided and it's not disabled. Implement logic to apply disabled styles (e.g., `opacity-50 cursor-not-allowed`) when the `disabled` prop is true.",
            "status": "done",
            "testStrategy": "Use a tool like Storybook or a temporary test page to render the `NavigationCard` with different props. Verify its appearance and behavior for enabled, disabled, and linked states."
          },
          {
            "id": 4,
            "title": "Add Standard Navigation Cards to Dashboard Grid",
            "description": "Integrate the `NavigationCard` component into the dashboard page to display the standard set of navigation options for all users. Arrange the cards in a responsive grid layout.",
            "dependencies": [
              "30.2",
              "30.3"
            ],
            "details": "In `app/dashboard/page.tsx`, create a container element with Tailwind CSS grid classes (e.g., `grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6`). Render four instances of the `NavigationCard` component for 'File Management' (`href='/dashboard/files'`), 'Profile Management', and 'Settings'. For the 'Reports' card, pass the `disabled={true}` prop and include 'Coming Soon' in its description.",
            "status": "done",
            "testStrategy": "Log in as a standard user. Verify that the four standard cards are displayed correctly in a grid. Check that the 'File Management' link navigates to the correct page. Confirm the 'Reports' card is visually disabled and not clickable. Resize the browser window to test the grid's responsiveness."
          },
          {
            "id": 5,
            "title": "Implement Conditional Rendering for Admin Panel Card",
            "description": "Add logic to the dashboard page to conditionally render the 'Admin Panel' navigation card. This card should only be visible to users with the 'ADMIN' role and should be visually distinct.",
            "dependencies": [
              "30.1",
              "30.4"
            ],
            "details": "In `app/dashboard/page.tsx`, use the user's role from the session data. Add a conditional rendering block: `{session.user.role === 'ADMIN' && <NavigationCard ... />}`. Configure this card with `title='Admin Panel'` and `href='/admin'`. To make it visually distinct, pass a custom `className` prop to the `NavigationCard` to apply a different border color or background highlight (e.g., `border-yellow-500`).",
            "status": "done",
            "testStrategy": "1. Log in as a user with the 'ADMIN' role. Verify the 'Admin Panel' card is visible, visually distinct, and links correctly to `/admin`. 2. Log in as a standard, non-admin user. Verify the 'Admin Panel' card is NOT rendered."
          },
          {
            "id": 6,
            "title": "Finalize Dashboard Layout and Responsiveness",
            "description": "Review and refine the overall layout, spacing, and styling of the dashboard page. Ensure the grid of cards is fully responsive and provides an optimal user experience on various screen sizes, from mobile to desktop.",
            "dependencies": [
              "30.5"
            ],
            "details": "Review `app/dashboard/page.tsx` and adjust Tailwind CSS classes as needed. Check for consistent padding and margins for the page container, header, and card grid. Add subtle hover effects to the `NavigationCard` component for better interactivity (e.g., `hover:border-primary`). Ensure the layout adapts gracefully to smaller viewports by adjusting the number of grid columns.",
            "status": "done",
            "testStrategy": "Use browser developer tools to test the dashboard on different device presets (e.g., iPhone, iPad, large desktop). Verify that the layout adjusts correctly, elements do not overlap, and all text remains readable and accessible across all tested screen sizes."
          }
        ]
      },
      {
        "id": 31,
        "title": "Add 'Back to Main Dashboard' Button to Admin Panel",
        "description": "Implement a navigation button within the admin dashboard interface that allows administrators to quickly and easily return to the main user dashboard.",
        "details": "This task involves adding a persistent navigation element to the admin panel layout. The button should be placed in a prominent, consistent location, such as the admin header or sidebar, to ensure it's accessible from any page within the `/admin` route group. Use a `<Link>` component from Next.js for client-side navigation, pointing to `/dashboard`. The button should be styled using the project's UI component library (e.g., Shadcn/ui) and include a descriptive label like 'Return to Dashboard' along with a relevant icon (e.g., `ArrowLeft` or `LayoutDashboard`). This modification will likely be made in the admin layout file (e.g., `app/admin/layout.tsx`).",
        "testStrategy": "1. Log in to the application using an account with the 'ADMIN' role. 2. Navigate to the main admin dashboard at `/admin`. 3. Verify that a 'Return to Dashboard' button is clearly visible in the admin layout (e.g., header). 4. Click the button. 5. Confirm that you are successfully redirected to the main user dashboard at `/dashboard`. 6. Navigate to another admin sub-page (if available) and confirm the button is still present and functional.",
        "status": "done",
        "dependencies": [
          26,
          30
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create the 'ReturnToDashboardButton' UI Component",
            "description": "Develop a self-contained UI component for the 'Return to Dashboard' button. This component will encapsulate the button's visual elements, including the icon and label, using the project's Shadcn/ui library.",
            "dependencies": [],
            "details": "Create a new component file, for example, at `components/ui/return-to-dashboard-button.tsx`. Inside this file, use the `<Button>` component from Shadcn/ui. Import the `ArrowLeft` icon from the `lucide-react` library and place it alongside the text label 'Return to Dashboard'. The component should accept standard button props. For now, it will not have any navigation logic.",
            "status": "done",
            "testStrategy": "Use a component viewer like Storybook or temporarily render the component on a test page to verify its appearance, responsiveness, and hover/active states."
          },
          {
            "id": 2,
            "title": "Integrate the Button into the Admin Layout",
            "description": "Modify the primary admin layout file to incorporate the `ReturnToDashboardButton` component. The button should be placed in a consistent, high-visibility area like the header or main navigation sidebar.",
            "dependencies": [
              "31.1"
            ],
            "details": "Locate and open the admin panel's root layout file, which is likely `app/admin/layout.tsx`. Import the `ReturnToDashboardButton` component created in subtask 31.1. Position the component within the layout's header or sidebar structure. Use Flexbox or Grid CSS properties to ensure it is properly aligned with other navigation elements.",
            "status": "done",
            "testStrategy": "Log in with an admin account and navigate to several different pages within the `/admin` route group. Confirm that the button is present and correctly positioned on all pages without disrupting the existing layout."
          },
          {
            "id": 3,
            "title": "Implement Client-Side Navigation Logic",
            "description": "Add the navigation functionality to the button, making it a functional link that directs the user from the admin panel back to the main user dashboard at `/dashboard` using Next.js client-side routing.",
            "dependencies": [
              "31.2"
            ],
            "details": "In the `app/admin/layout.tsx` file, import the `Link` component from `next/link`. Wrap the `<ReturnToDashboardButton />` instance with this `Link` component, setting the `href` prop to `\"/dashboard\"`. To ensure proper styling and accessibility, pass the `asChild` prop to the Shadcn/ui `<Button>` component so that it renders as the anchor tag from the `Link` component.",
            "status": "done",
            "testStrategy": "1. Log in as an administrator and go to any admin page. 2. Click the 'Return to Dashboard' button. 3. Verify that the browser navigates to `/dashboard` smoothly and without a full page reload. 4. Check the browser's network tab to confirm client-side navigation occurred."
          }
        ]
      },
      {
        "id": 32,
        "title": "Implement 'My Profile' Page for User Account Management",
        "description": "Create a 'My Profile' page at /dashboard/profile where authenticated users can view their account details, update their name, and securely change their password.",
        "details": "This task involves creating a new page and two API endpoints. The page should be located at `app/dashboard/profile/page.tsx` and must be a protected route. The UI will be built using shadcn/ui components and should feature two separate forms within Cards: one for updating the user's name and another for changing the password. It should also display non-editable account information like email, role, and creation date. The forms will use `react-hook-form` with the Zod resolver for client-side validation. Two new API endpoints are required: 1. `PATCH /api/profile`: This endpoint will handle name updates. It must be secured, validate the incoming data with Zod, and use Prisma to update the user's record, ensuring a user can only modify their own data. 2. `PATCH /api/profile/change-password`: This endpoint will handle password changes. It must verify the user's current password using `bcrypt.compare` against the stored hash before hashing and saving the new password.",
        "testStrategy": "1. **Route Protection**: Attempt to access `/dashboard/profile` while logged out and verify redirection to the login page. Log in and confirm access is granted. 2. **UI Verification**: Confirm the page correctly displays the logged-in user's name, email, and role. 3. **Profile Update**: Test the name change form's client-side validation (e.g., submitting an empty name). Successfully submit a new name and verify a success notification appears, the UI updates, and the change is reflected in the database. 4. **Password Change**: Test the password form's validation (e.g., mismatched new passwords, weak password). Submit with an incorrect current password and verify a specific error message is shown. Submit with the correct current password and a new valid password. Verify the success message, then log out. Confirm login is successful with the new password and fails with the old password. 5. **API Security**: Use an API client to send unauthenticated requests to both PATCH endpoints and verify a 401 Unauthorized response is returned.",
        "status": "done",
        "dependencies": [
          5,
          7,
          8,
          14,
          17,
          22
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Zod Schemas for Profile and Password Validation",
            "description": "Create two Zod schemas to validate the data for the profile update and password change forms. The profile schema will validate the 'name' field, and the password schema will validate 'currentPassword', 'newPassword', and 'confirmPassword', ensuring the new passwords match.",
            "dependencies": [],
            "details": "Create a new file at `lib/validations/profile.ts`. Export two schemas: `updateProfileSchema` with a `name` field (e.g., `z.string().min(2, 'Name must be at least 2 characters')`) and `changePasswordSchema` with `currentPassword`, `newPassword` (e.g., `z.string().min(8, 'Password must be at least 8 characters')`), and `confirmPassword`. Use Zod's `.refine()` method on the `changePasswordSchema` to validate that `newPassword` and `confirmPassword` are identical.",
            "status": "done",
            "testStrategy": "Write unit tests for the schemas to ensure they correctly validate both valid and invalid data structures, including edge cases like empty strings, short passwords, and mismatched confirmation passwords."
          },
          {
            "id": 2,
            "title": "Set Up Profile Page File Structure and Protected Route",
            "description": "Create the necessary directory and file for the new profile page at `/dashboard/profile`. Ensure this route is protected and only accessible to authenticated users by updating the middleware configuration.",
            "dependencies": [],
            "details": "Create the folder `app/dashboard/profile/`. Inside, create a `page.tsx` file with a basic placeholder React component (e.g., `<div>My Profile Page</div>`). Verify that the `middleware.ts` file (as per Task 17) includes `/dashboard/:path*` or specifically `/dashboard/profile` in its `matcher` config array to enforce authentication for this route.",
            "status": "done",
            "testStrategy": "Attempt to navigate to `/dashboard/profile` while logged out and verify redirection to the login page. Log in as a user and navigate to the page again to confirm the placeholder content is rendered successfully."
          },
          {
            "id": 3,
            "title": "Implement `PATCH /api/profile` Endpoint for Name Update",
            "description": "Create the API route handler to update the authenticated user's name. This endpoint will receive the new name, validate it using the Zod schema, and update the user record in the database.",
            "dependencies": [
              "32.1"
            ],
            "details": "Create the file `app/api/profile/route.ts`. Implement the `PATCH` handler. Use a helper function or `getServerSession` from `next-auth` to get the current user's session. If no session exists, return a 401 Unauthorized error. Parse the request body and validate it against the `updateProfileSchema`. If valid, use Prisma to update the `name` for the user identified by `session.user.id`. Return a 200 OK response with the updated user data. Handle potential database errors.",
            "status": "done",
            "testStrategy": "Use an API client like Postman to send PATCH requests to `/api/profile`. Test with a valid authentication token and a valid name. Verify the database is updated. Test without a token (expect 401), and with invalid data (e.g., empty name, expect 400)."
          },
          {
            "id": 4,
            "title": "Implement `PATCH /api/profile/change-password` Endpoint",
            "description": "Create the API route handler to securely change the authenticated user's password. It must verify the user's current password before hashing and saving the new password.",
            "dependencies": [
              "32.1"
            ],
            "details": "Create the file `app/api/profile/change-password/route.ts`. Implement the `PATCH` handler. Secure the route by checking for a valid session. Validate the request body using `changePasswordSchema`. Fetch the full user record from the database. Use `bcrypt.compare` to check if the provided `currentPassword` matches the stored hash. If it does not match, return a 400 Bad Request error. If it matches, hash the `newPassword` with `bcrypt.hash` and update the user's password field in the database. Return a 200 OK success message.",
            "status": "done",
            "testStrategy": "Using an API client, test the success case with a valid token and correct current password. Test failure cases: incorrect current password (expect 400), new passwords not matching in the request body (expect 400), and unauthenticated request (expect 401)."
          },
          {
            "id": 5,
            "title": "Create `AccountInfo` Component to Display User Details",
            "description": "Develop a React component to display non-editable user account information, such as email, role, and account creation date, within a `shadcn/ui` Card.",
            "dependencies": [
              "32.2"
            ],
            "details": "Create a new component file at `components/dashboard/profile/account-info.tsx`. This component will accept a user object as a prop. Use `shadcn/ui` components like `Card`, `CardHeader`, `CardTitle`, `CardContent`, and `Label` to create a read-only view of the user's `email`, `role`, and `createdAt` properties. Format the date for better readability.",
            "status": "done",
            "testStrategy": "Use Storybook or render the component on the profile page with mock user data to verify that it displays all information correctly and matches the intended design."
          },
          {
            "id": 6,
            "title": "Create `UpdateProfileForm` Component",
            "description": "Build the client-side form for updating the user's name. This component will use `react-hook-form`, the Zod resolver, and `shadcn/ui` components, and will submit data to the `PATCH /api/profile` endpoint.",
            "dependencies": [
              "32.1",
              "32.3"
            ],
            "details": "Create `components/dashboard/profile/update-profile-form.tsx`. Mark it as a client component (`'use client'`). Use the `useForm` hook from `react-hook-form` with the `zodResolver` and `updateProfileSchema`. The form should be pre-populated with the user's current name passed via props. Build the UI with `shadcn/ui` `Form`, `FormField`, `Input`, and `Button` components inside a `Card`. The `onSubmit` handler will make a `fetch` call to `PATCH /api/profile`.",
            "status": "done",
            "testStrategy": "Render the component and test client-side validation by entering an invalid name. Mock the API call to verify that a valid submission sends the correct payload. Check that the form is pre-filled correctly."
          },
          {
            "id": 7,
            "title": "Create `ChangePasswordForm` Component",
            "description": "Build the client-side form for changing the user's password. This component will use `react-hook-form`, the Zod resolver, and `shadcn/ui` components, and will submit data to the `PATCH /api/profile/change-password` endpoint.",
            "dependencies": [
              "32.1",
              "32.4"
            ],
            "details": "Create `components/dashboard/profile/change-password-form.tsx` as a client component. Use `react-hook-form` with the `zodResolver` and `changePasswordSchema`. The form will contain three `Input` fields of `type='password'` for current password, new password, and confirmation. The `onSubmit` handler will call the `PATCH /api/profile/change-password` endpoint. For security, ensure the form fields are cleared after a successful submission.",
            "status": "done",
            "testStrategy": "Render the component and test client-side validation (e.g., new passwords don't match, new password is too short). Mock the API call on submit to verify the correct payload is sent. Ensure password fields do not autocomplete."
          },
          {
            "id": 8,
            "title": "Assemble the Main `/dashboard/profile` Page",
            "description": "Integrate the `AccountInfo`, `UpdateProfileForm`, and `ChangePasswordForm` components into the main profile page. Fetch the current user's data on the server to pass down as props.",
            "dependencies": [
              "32.2",
              "32.5",
              "32.6",
              "32.7"
            ],
            "details": "In `app/dashboard/profile/page.tsx`, convert the component to an `async` server component. Use `getServerSession` to get the session and fetch the complete user object from the database using Prisma. Pass the user data as props to the `AccountInfo` and `UpdateProfileForm` components. Arrange the three components on the page using a layout (e.g., a CSS grid or flexbox) and add appropriate headings like 'Account Information', 'Update Profile', and 'Change Password'.",
            "status": "done",
            "testStrategy": "Load the `/dashboard/profile` page as an authenticated user. Verify that all three components render correctly and that the user's name and other details are displayed and pre-filled in the appropriate places."
          },
          {
            "id": 9,
            "title": "Implement Client-Side Loading and Feedback States",
            "description": "Enhance the `UpdateProfileForm` and `ChangePasswordForm` components with loading indicators and user feedback (e.g., toast notifications) for success and error states.",
            "dependencies": [
              "32.6",
              "32.7"
            ],
            "details": "In both form components, use a state variable (e.g., `isSubmitting`) to disable the submit button and show a loading spinner during the API call. In the `onSubmit` function, wrap the `fetch` call in a `try...catch` block. On a successful response, show a success toast (e.g., 'Profile updated!'). On a failed response, parse the error message from the JSON body and display an error toast (e.g., 'Incorrect current password').",
            "status": "done",
            "testStrategy": "Manually test both forms. Verify the submit button is disabled and a spinner appears on submission. Trigger a successful update and confirm a success toast appears. Trigger a failed update (e.g., wrong password) and confirm a specific error toast is shown."
          },
          {
            "id": 10,
            "title": "Perform End-to-End Integration and Security Review",
            "description": "Conduct a full review and testing of the entire 'My Profile' feature, ensuring all components and APIs work together correctly and security measures are effective.",
            "dependencies": [
              "32.3",
              "32.4",
              "32.8",
              "32.9"
            ],
            "details": "Execute a full test plan: 1. Log in and navigate to `/dashboard/profile`. 2. Verify all data is displayed correctly. 3. Successfully update the name and refresh the page to confirm persistence. 4. Successfully change the password. 5. Log out and log back in with the new password. 6. Attempt to change the password with an incorrect current password and verify the error feedback. 7. Review browser network tab to ensure no sensitive data (like password hashes) is returned in API responses.",
            "status": "done",
            "testStrategy": "This is a comprehensive manual test of the entire feature flow, simulating real user actions from login to profile modification to logout and re-login."
          }
        ]
      },
      {
        "id": 33,
        "title": "Add DNI Field to User Model and Validations",
        "description": "Modify the Prisma schema to add a mandatory and unique DNI field to the User model. This task includes creating the corresponding database migration and updating Zod validation schemas for the user registration and profile management pages.",
        "details": "1. **Update Prisma Schema**: Modify the `User` model in `prisma/schema.prisma` to include the new `dni` field. It must be a non-nullable, unique string.\n```prisma\nmodel User {\n  id        String   @id @default(cuid())\n  email     String   @unique\n  name      String?\n  dni       String   @unique\n  password  String\n  // ... other fields\n}\n```\n2. **Database Migration**: Create and apply a new database migration to add the `dni` column to the existing `User` table. Run the command: `npx prisma migrate dev --name add_dni_to_user`. Follow the CLI prompts to handle existing records if necessary. After the migration, regenerate the Prisma Client with `npx prisma generate`.\n3. **Update Zod Schemas**: Modify the Zod validation schemas used for user registration and profile updates to include the `dni` field. Implement appropriate validation rules, such as a regex for format validation.\n```typescript\n// Example for a registration schema\nexport const RegisterSchema = z.object({\n  // ... other fields\n  dni: z.string().regex(/^[0-9]{8}[TRWAGMYFPDXBNJZSQVHLCKE]$/i, {\n    message: \"Invalid DNI format. It should be 8 numbers followed by a letter.\"\n  }),\n});\n```\n4. **Backend API Integration**: Update the registration API endpoint (`/api/auth/register`) and the profile update endpoint (from Task #32) to handle receiving, validating, and saving the `dni` field in the database. Ensure uniqueness constraints are handled gracefully, returning a user-friendly error message (e.g., 'DNI already in use').\n5. **Frontend UI Integration**: Add a new `Input` field for the DNI to the registration form component (from Task #15) and the profile management form on the `/dashboard/profile` page (from Task #32). Connect this field to the form state and validation logic.",
        "testStrategy": "1. **Migration Verification**: After running `npx prisma migrate dev`, connect to the PostgreSQL database and inspect the `User` table. Confirm that a `dni` column exists with `TEXT` type and has `NOT NULL` and `UNIQUE` constraints.\n2. **Registration Flow**: Navigate to the `/register` page. Verify the DNI input field is present and marked as required. Test client-side validation by entering an incorrectly formatted DNI and confirm the specific error message appears. Successfully register a new user with a valid DNI and verify the value is correctly stored in the database. Attempt to register another user with the same DNI and verify that the API returns a conflict error which is displayed to the user.\n3. **Profile Management Flow**: Log in and navigate to the `/dashboard/profile` page. Verify the DNI field is present. Test updating the DNI with a valid value and confirm it's saved. Test updating with an invalid format and confirm validation prevents submission. Attempt to update the DNI to one that is already in use by another user and verify the backend error is handled and displayed correctly.",
        "status": "done",
        "dependencies": [
          2,
          5,
          15,
          32
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Update Prisma Schema with DNI Field",
            "description": "Modify the `User` model in the `prisma/schema.prisma` file to include a new `dni` field. This field must be a non-nullable, unique string to ensure data integrity.",
            "dependencies": [],
            "details": "In `prisma/schema.prisma`, add the line `dni String @unique` to the `User` model. This defines the new field as a required, unique string in the database schema.",
            "status": "done",
            "testStrategy": "Review the `prisma/schema.prisma` file to confirm the `dni` field has been correctly added to the `User` model with the `@unique` attribute."
          },
          {
            "id": 2,
            "title": "Create and Apply Database Migration for DNI Field",
            "description": "Generate and apply a new database migration to add the `dni` column to the `User` table in the PostgreSQL database, reflecting the schema changes.",
            "dependencies": [
              "33.1"
            ],
            "details": "Execute the command `npx prisma migrate dev --name add_dni_to_user` in the terminal. If prompted, provide a default value for existing user records (e.g., a placeholder string) to handle the non-nullable constraint. Afterwards, run `npx prisma generate` to update the Prisma Client with the new schema.",
            "status": "done",
            "testStrategy": "Connect to the PostgreSQL database using a client like psql or a GUI tool. Inspect the `User` table schema and verify that the `dni` column has been added with the correct type (`TEXT` or `VARCHAR`) and has both `NOT NULL` and `UNIQUE` constraints applied."
          },
          {
            "id": 3,
            "title": "Update Zod Schemas for DNI Validation",
            "description": "Modify the Zod validation schemas used for user registration and profile updates to include validation rules for the new `dni` field.",
            "dependencies": [],
            "details": "In the relevant Zod schema files (e.g., for registration and profile updates), add the `dni` field. Implement a regex to validate the Spanish DNI format. Example: `dni: z.string().regex(/^[0-9]{8}[TRWAGMYFPDXBNJZSQVHLCKE]$/i, { message: \"Invalid DNI format. It should be 8 numbers followed by a letter.\" })`.",
            "status": "done",
            "testStrategy": "Create unit tests for the updated Zod schemas. Pass valid and invalid DNI strings to the schema's `safeParse` method and assert that it validates or rejects them correctly, returning the appropriate error messages for invalid inputs."
          },
          {
            "id": 4,
            "title": "Integrate DNI Field into Backend API Endpoints",
            "description": "Update the backend logic for user registration and profile management to handle receiving, validating, and saving the new `dni` field.",
            "dependencies": [
              "33.2",
              "33.3"
            ],
            "details": "Modify the API route handlers for registration (`/api/auth/register`) and profile updates. Ensure the incoming `dni` is validated using the updated Zod schema. Update the Prisma `create` and `update` calls to include the `dni` field. Implement try-catch blocks to handle potential unique constraint violations from Prisma and return a user-friendly error message like 'DNI already in use.'",
            "status": "done",
            "testStrategy": "Use an API client like Postman or write integration tests to send requests to the registration and profile update endpoints with: 1) a valid DNI, 2) an invalid DNI format, and 3) a DNI that already exists. Verify that the API responds with the correct status codes and JSON error messages for each case."
          },
          {
            "id": 5,
            "title": "Add DNI Input Field to Frontend Forms",
            "description": "Modify the user registration and profile management forms in the frontend application to include a new input field for the DNI, connecting it to the form state and validation.",
            "dependencies": [
              "33.4"
            ],
            "details": "In the registration form component (from Task #15) and the profile page form (`/dashboard/profile`, from Task #32), add a new `FormField` for the DNI using a shadcn/ui `Input` component. Connect this input to the form's state management (e.g., React Hook Form) and link it to the updated Zod schema for client-side validation.",
            "status": "done",
            "testStrategy": "Navigate to the registration and profile pages. Verify the DNI input field is rendered. Test client-side validation by entering invalid formats and confirming error messages appear. Perform an end-to-end test by registering a new user with a valid DNI and verifying it's saved correctly in the database."
          }
        ]
      },
      {
        "id": 34,
        "title": "Create Two-Factor Authentication (TOTP) Prisma Model",
        "description": "Define a new `TwoFactorAuth` model in the Prisma schema to support Time-based One-Time Password (TOTP) functionality. This includes fields for the secret, backup codes, and a one-to-one relationship with the User model.",
        "details": "This task involves modifying the `prisma/schema.prisma` file to introduce the necessary database structure for 2FA. \n1. **Define the `TwoFactorAuth` Model**: Create a new model with fields to store the TOTP secret, configuration, and status. The secret should be unique. Backup codes will be stored as an array of strings.\n2. **Establish One-to-One Relationship**: Add a relation field to the `User` model and use a unique foreign key (`userId`) in the `TwoFactorAuth` model to enforce a one-to-one relationship. Add `onDelete: Cascade` to ensure data integrity when a user is deleted.\n3. **Set Defaults**: Configure default values for `digits` (6) and `period` (30 seconds), which are standard for TOTP implementations.\n4. **Create Database Migration**: After updating the schema, generate and apply a new database migration.\n\n**Prisma Schema Changes (`prisma/schema.prisma`):**\n```prisma\nmodel User {\n  // ... existing fields: id, email, name, password, etc.\n  twoFactorAuth TwoFactorAuth?\n}\n\nmodel TwoFactorAuth {\n  id           String   @id @default(cuid())\n  secret       String   @unique\n  digits       Int      @default(6)\n  period       Int      @default(30)\n  backupCodes  String[]\n  enabledAt    DateTime?\n\n  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\n  userId String @unique\n}\n```\n\n**Migration Command:**\n```bash\nnpx prisma migrate dev --name add_two_factor_auth_model\n```",
        "testStrategy": "1. **Migration Execution**: Run the `npx prisma migrate dev` command and ensure it completes without errors. \n2. **Database Schema Verification**: Connect to the PostgreSQL database using a tool like Prisma Studio (`npx prisma studio`) or a standard SQL client. Confirm that a new table named `TwoFactorAuth` has been created. \n3. **Table Structure Validation**: Inspect the `TwoFactorAuth` table and verify that all specified columns (`id`, `secret`, `digits`, `period`, `backupCodes`, `enabledAt`, `userId`) exist with the correct data types (e.g., `digits` and `period` as integers, `backupCodes` as a text array). \n4. **Constraint Verification**: Confirm that the `userId` column has a `UNIQUE` constraint and a foreign key relationship to the `id` column of the `User` table with a cascade delete rule. \n5. **Prisma Client Generation**: Run `npx prisma generate` and inspect the generated types in `node_modules/.prisma/client` to ensure the `TwoFactorAuth` model and its relations are correctly typed and available for use in the application code.",
        "status": "done",
        "dependencies": [
          3,
          32
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Add DNI Field to User Registration",
        "description": "Modify the user registration form and backend API to include a DNI field. This involves updating the UI, implementing validation for an 8-character alphanumeric format, and adjusting the database schema.",
        "details": "1. **Database Schema Update**: Modify the `User` model in `prisma/schema.prisma` to add a new optional and unique `dni` field. `dni String? @unique`. After updating, run `npx prisma migrate dev --name add_dni_to_user` to apply the migration.\n2. **Zod Schema Update**: In `lib/zod.ts`, update the `registerSchema` to include the `dni` field. Add validation to ensure it is a string that matches an 8-character alphanumeric format. Example: `dni: z.string().regex(/^[a-zA-Z0-9]{8}$/, { message: \"DNI must be 8 alphanumeric characters.\" })`.\n3. **Frontend Form Modification**: Update the `RegistrationForm` component (from Task 15) to include a new text input for the DNI. Connect this input to the form's state management and ensure it displays validation errors derived from the updated Zod schema.\n4. **Backend API Update**: In the registration API endpoint (`app/api/auth/register/route.ts`), modify the handler to parse and validate the new `dni` field from the request body. Ensure the validated DNI is included in the data object when creating the new user with `prisma.user.create()`.",
        "testStrategy": "1. **UI Verification**: Navigate to the `/register` page and confirm that the new 'DNI' input field is present in the form.\n2. **Client-Side Validation**: Attempt to submit the registration form with invalid DNI values (e.g., less than 8 characters, more than 8 characters, contains symbols). Verify that a client-side validation error message is displayed and the form submission is blocked.\n3. **Successful Registration**: Complete and submit the registration form with valid data, including a correctly formatted 8-character alphanumeric DNI.\n4. **Database Verification**: After a successful registration, query the database to confirm that the new user record has been created and that the `dni` column is correctly populated with the value provided during registration.",
        "status": "done",
        "dependencies": [
          15,
          7
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Actualizar Registro y Sesión para Incluir DNI",
        "description": "Modificar el proceso de registro de usuarios para incluir un campo DNI, asegurando su unicidad en la base de datos, y actualizar la configuración de NextAuth para que el DNI esté disponible en la sesión del usuario.",
        "details": "Esta tarea requiere la modificación de tres áreas principales: el esquema de la base de datos, la lógica de la API de registro y la configuración de la sesión de NextAuth. 1. **Actualizar Esquema de Prisma**: Añadir un campo `dni` al modelo `User` en `prisma/schema.prisma`. Este campo debe ser de tipo String y único para evitar duplicados. ```prisma\nmodel User {\n  // ... otros campos\n  dni      String?   @unique\n}\n``` Después de modificar el esquema, ejecuta la migración: `npx prisma migrate dev --name add_dni_to_user`. 2. **Modificar API de Registro**: En el endpoint `app/api/auth/register/route.ts`, actualiza el esquema de validación de Zod para incluir el campo `dni`. Antes de crear el usuario con `prisma.user.create`, realiza una consulta para verificar si ya existe un usuario con el DNI proporcionado. Si existe, devuelve un error 409 (Conflict). Asegúrate de pasar el `dni` en los datos al crear el nuevo usuario. 3. **Actualizar Configuración de NextAuth**: En el archivo de configuración de NextAuth (p. ej., `auth.config.ts` o `app/api/auth/[...nextauth]/route.ts`), modifica los callbacks `jwt` y `session`. En el callback `jwt`, añade el DNI del objeto de usuario al token. En el callback `session`, extrae el DNI del token y añádelo al objeto de sesión para que esté disponible en el cliente.",
        "testStrategy": "1. **Prueba de Registro Exitoso**: Intenta registrar un nuevo usuario con un DNI válido y único. Verifica que el usuario se crea correctamente en la base de datos con el DNI almacenado. 2. **Prueba de DNI Duplicado**: Intenta registrar un segundo usuario utilizando el mismo DNI que en la prueba anterior. Verifica que la API devuelve un error específico indicando que el DNI ya está en uso y que no se crea un nuevo usuario. 3. **Prueba de Validación**: Intenta registrar un usuario sin proporcionar el campo DNI (si es obligatorio) y verifica que la validación de Zod devuelve el error correspondiente. 4. **Verificación de Sesión**: Después de registrar e iniciar sesión con el nuevo usuario, inspecciona el objeto de sesión en el cliente (usando las herramientas de desarrollo del navegador o una página de depuración). Confirma que el objeto `session.user` contiene el campo `dni` con el valor correcto.",
        "status": "done",
        "dependencies": [
          7,
          8,
          11
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Install and Configure TOTP Libraries (otplib, qrcode)",
        "description": "Install and configure the `otplib` and `qrcode` libraries to support the generation and verification of TOTP secrets and QR codes for the two-factor authentication feature.",
        "details": "This task involves setting up the core backend dependencies for implementing TOTP-based 2FA. First, install the necessary packages: `npm install otplib qrcode`. Also, install the TypeScript types for qrcode: `npm install @types/qrcode --save-dev`. After installation, create a new utility file, for example, `lib/totp.ts`, to encapsulate all TOTP-related logic. This service will expose functions for generating a new secret, creating an `otpauth://` URI for authenticator apps, generating a QR code data URL from that URI, and verifying a user-provided token against the stored secret. The service name used in the `otpauth://` URI should be configurable, ideally sourced from an environment variable.",
        "testStrategy": "1. **Unit Testing**: Create unit tests for the new TOTP utility module (`lib/totp.ts`). Verify that `generateSecret()` returns a non-empty string. Confirm that `generateOtpAuthUri()` produces a correctly formatted URI string starting with `otpauth://totp/`. Test the `verifyToken()` function by generating a token for a known secret and ensuring the function returns `true`, then test with an incorrect token to ensure it returns `false`. 2. **Manual Verification**: Create a temporary API route that generates a secret and a corresponding QR code data URL. Log this data URL to the console. Copy the data URL into a browser to render the QR code. Scan the QR code with an authenticator app (e.g., Google Authenticator, Authy). Verify that the app successfully adds the account. Finally, use a token from the app to call the `verifyToken` function within the test route and confirm it returns `true`.",
        "status": "done",
        "dependencies": [
          3,
          34
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Install TOTP and QR Code Dependencies",
            "description": "Install the necessary npm packages `otplib` and `qrcode`, along with the TypeScript type definitions for `qrcode`, to provide the foundational libraries for TOTP generation and QR code creation.",
            "dependencies": [],
            "details": "Execute the following commands in the terminal to add the required dependencies to the project: `npm install otplib qrcode` and `npm install @types/qrcode --save-dev`.",
            "status": "done",
            "testStrategy": "After installation, verify that `otplib` and `qrcode` are listed in the `dependencies` section and `@types/qrcode` is in the `devDependencies` section of the `package.json` file. Ensure the project compiles without type errors when importing these packages."
          },
          {
            "id": 2,
            "title": "Create TOTP Utility and Secret Generation Function",
            "description": "Create a dedicated utility file for all TOTP-related logic and implement the core function for generating a new, unique secret for users enabling two-factor authentication.",
            "dependencies": [
              "37.1"
            ],
            "details": "Create a new file at `lib/totp.ts`. Within this file, import the `authenticator` from `otplib` and implement an exported function `generateSecret()` that calls `authenticator.generateSecret()` to produce and return a new base32 encoded secret string.",
            "status": "done",
            "testStrategy": "Write a unit test for the `generateSecret()` function. Assert that the function returns a non-empty string and that subsequent calls produce different secrets."
          },
          {
            "id": 3,
            "title": "Implement otpauth URI and QR Code Generation",
            "description": "Develop functions to generate the standard `otpauth://` URI for authenticator app compatibility and to convert this URI into a QR code image data URL for frontend display.",
            "dependencies": [
              "37.2"
            ],
            "details": "In `lib/totp.ts`, create a function `generateOtpAuthUri(accountName, secret)` that constructs the URI string. The issuer name within the URI should be sourced from an environment variable (e.g., `process.env.NEXT_PUBLIC_APP_NAME`). Then, create a function `generateQrCodeDataURL(uri)` that uses `qrcode.toDataURL()` to convert the URI into a data URL.",
            "status": "done",
            "testStrategy": "Unit test the `generateOtpAuthUri` function to ensure it produces a correctly formatted URI string. For `generateQrCodeDataURL`, verify that the output is a string that starts with `data:image/png;base64,`."
          },
          {
            "id": 4,
            "title": "Implement TOTP Token Verification Logic",
            "description": "Implement the server-side function to validate a user-provided TOTP token against their stored secret, which is the final step in authenticating a user via 2FA.",
            "dependencies": [
              "37.2"
            ],
            "details": "In `lib/totp.ts`, add an exported function `verifyToken({ token, secret })`. This function will use `authenticator.verify({ token, secret })` from the `otplib` library to check the validity of the token. The function should return a boolean result.",
            "status": "done",
            "testStrategy": "Write unit tests for the `verifyToken` function. Use `otplib` to generate a valid token for a known secret and assert that verification returns `true`. Test with an incorrect token to ensure verification returns `false`."
          }
        ]
      },
      {
        "id": 38,
        "title": "Implement API Endpoints for TOTP Two-Factor Authentication",
        "description": "Create the necessary backend API routes to enable, verify, disable, and manage TOTP-based 2FA, including generating backup codes for account recovery.",
        "details": "This task involves setting up the complete backend infrastructure for Time-based One-Time Password (TOTP) functionality. First, update the Prisma schema to include 2FA details on the `User` model and create a new model for single-use backup codes. Then, implement four protected API endpoints. Libraries such as `otplib` for TOTP logic and `qrcode` for QR code generation are recommended. All secrets and backup codes must be stored securely (encrypted or hashed) in the database.\n\n**1. Prisma Schema Updates:**\nModify `prisma/schema.prisma`:\n```prisma\nmodel User {\n  // ... existing fields\n  isTwoFactorEnabled  Boolean  @default(false)\n  twoFactorSecret     String?  // Will be stored encrypted\n  backupCodes         BackupCode[]\n}\n\nmodel BackupCode {\n  id        String   @id @default(cuid())\n  codeHash  String   @unique\n  isUsed    Boolean  @default(false)\n  createdAt DateTime @default(now())\n  userId    String\n  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n}\n```\nRun `npx prisma migrate dev` after updating the schema.\n\n**2. Endpoint Implementation:**\n- **`POST /api/auth/2fa/setup`**: For an authenticated user, generate a new TOTP secret using `otplib`. Generate an `otpauth://` URI and convert it to a QR code data URL using `qrcode`. Return the data URL to the client. The secret should be temporarily stored (e.g., encrypted on the user record) pending verification.\n- **`POST /api/auth/2fa/verify`**: For an authenticated user, validate the TOTP code sent from the client against the stored secret using `otplib.check()`. On first successful verification during setup, this endpoint should finalize the process by setting `isTwoFactorEnabled = true` on the User model.\n- **`POST /api/auth/2fa/disable`**: For an authenticated user, this endpoint should require password re-verification for security. Upon success, it will set `isTwoFactorEnabled = false`, clear the `twoFactorSecret`, and delete all associated backup codes.\n- **`GET /api/auth/2fa/backup-codes`**: For an authenticated user with 2FA enabled, this endpoint should also require password re-verification. It will generate a new set of single-use backup codes (e.g., 10), hash them, and store them in the `BackupCode` table, deleting any old ones. It must return the plaintext codes to the user for this one and only time.",
        "testStrategy": "Testing will be performed using an API client like Postman or Insomnia against a local development server.\n\n1.  **Security Checks**: Attempt to access each of the four endpoints (`/setup`, `/verify`, `/disable`, `/backup-codes`) without an active session. Verify that each request is rejected with a 401 Unauthorized or 403 Forbidden status.\n2.  **Setup and Verification Flow**: \n    - As a logged-in user, send a POST request to `/api/auth/2fa/setup`. Verify a 200 OK response containing a valid QR code data URL.\n    - Scan the QR code with an authenticator app (e.g., Google Authenticator).\n    - Send a POST request to `/api/auth/2fa/verify` with an invalid code. Verify a failure response (e.g., 400 Bad Request).\n    - Send a POST request to `/api/auth/2fa/verify` with the correct code from the app. Verify a 200 OK response and check the database to confirm `isTwoFactorEnabled` is set to `true` for the user.\n3.  **Backup Code Generation**: \n    - With 2FA enabled, send a GET request to `/api/auth/2fa/backup-codes` (including password for re-authentication). Verify a 200 OK response containing an array of plaintext backup codes.\n    - Inspect the `BackupCode` table in the database to confirm the new codes are stored and are hashed (`codeHash`).\n4.  **Disable Flow**: \n    - With 2FA enabled, send a POST request to `/api/auth/2fa/disable` (including password for re-authentication). Verify a 200 OK response.\n    - Check the database to confirm `isTwoFactorEnabled` is `false`, `twoFactorSecret` is null, and all associated backup codes have been deleted.",
        "status": "done",
        "dependencies": [
          8,
          17
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Update Prisma Schema for 2FA and Backup Codes",
            "description": "Modify the `schema.prisma` file to support TOTP 2FA. This involves adding `isTwoFactorEnabled` and `twoFactorSecret` fields to the `User` model and creating a new `BackupCode` model for recovery purposes.",
            "dependencies": [],
            "details": "Apply the provided schema changes to `prisma/schema.prisma`. Add `isTwoFactorEnabled Boolean @default(false)` and `twoFactorSecret String?` to the `User` model. Create the `BackupCode` model as specified in the task description. After saving the file, run `npx prisma migrate dev --name add_2fa_support` to apply the changes to the database. Ensure you have utility functions for encrypting and decrypting secrets, as the `twoFactorSecret` must not be stored in plaintext.",
            "status": "done",
            "testStrategy": "After running the migration, inspect the database schema using a tool like Prisma Studio (`npx prisma studio`) to confirm that the `User` table has the new columns and the `BackupCode` table exists with the correct structure and relations."
          },
          {
            "id": 2,
            "title": "Create API Endpoint for 2FA Setup (`/api/auth/2fa/setup`)",
            "description": "Implement a protected API route that generates a new TOTP secret and a corresponding QR code for the authenticated user to scan with their authenticator app.",
            "dependencies": [
              "38.1"
            ],
            "details": "Create a `POST` endpoint at `/api/auth/2fa/setup`. This route must be protected and accessible only by authenticated users (relying on middleware from Task 17). Use the `otplib` library to generate a secret (`authenticator.generateSecret()`). Construct an `otpauth://` URI. Use the `qrcode` library to convert this URI into a data URL. Encrypt the generated secret and store it in the `twoFactorSecret` field for the current user, but leave `isTwoFactorEnabled` as `false` until verification. Return the QR code data URL to the client.",
            "status": "done",
            "testStrategy": "As an authenticated user, send a POST request to the endpoint. Verify the response is a 200 OK and contains a valid QR code data URL. Decode the QR code to ensure it contains the correct `otpauth://` URI. Check the database to confirm the user's `twoFactorSecret` field is populated with an encrypted string and `isTwoFactorEnabled` remains `false`."
          },
          {
            "id": 3,
            "title": "Create API Endpoint for 2FA Verification and Enablement (`/api/auth/2fa/verify`)",
            "description": "Implement the endpoint that verifies the user's TOTP code. Upon successful verification during initial setup, it permanently enables 2FA for the user's account.",
            "dependencies": [
              "38.2"
            ],
            "details": "Create a `POST` endpoint at `/api/auth/2fa/verify`. This route must be protected. It should accept a `token` (the 6-digit code) in the request body. Retrieve the authenticated user's record, decrypt their `twoFactorSecret`, and use `otplib.check(token, decryptedSecret)` to validate the code. If the code is valid and `isTwoFactorEnabled` is currently `false`, update the user's record to set `isTwoFactorEnabled = true`. Return a success response. If the code is invalid, return a 400 error.",
            "status": "done",
            "testStrategy": "After using the setup endpoint, scan the QR code with an authenticator app. Send a POST request to `/verify` with the generated 6-digit code. Verify the response is successful and the user's `isTwoFactorEnabled` flag in the database is now `true`. Test again with an incorrect or expired code and verify a 400-level error is returned."
          },
          {
            "id": 4,
            "title": "Create API Endpoint for Disabling 2FA (`/api/auth/2fa/disable`)",
            "description": "Implement a secure endpoint for an authenticated user to disable 2FA on their account. This action requires password re-verification for security.",
            "dependencies": [
              "38.3"
            ],
            "details": "Create a `POST` endpoint at `/api/auth/2fa/disable`. This route must be protected. The request body must include the user's current `password`. Fetch the user from the database and use `bcrypt.compare` to verify the provided password against their stored hash. If the password is correct, update the user record: set `isTwoFactorEnabled = false` and `twoFactorSecret = null`. Additionally, execute a `prisma.backupCode.deleteMany({ where: { userId: user.id } })` to remove all associated backup codes. If the password is incorrect, return a 401 Unauthorized error.",
            "status": "done",
            "testStrategy": "For a user with 2FA enabled, send a POST request to `/disable` with an incorrect password and verify it fails. Send another request with the correct password. Verify the response is successful and the database reflects the changes: `isTwoFactorEnabled` is `false`, `twoFactorSecret` is `null`, and all related entries in the `BackupCode` table have been deleted."
          },
          {
            "id": 5,
            "title": "Create API Endpoint for Generating Backup Codes (`/api/auth/2fa/backup-codes`)",
            "description": "Implement an endpoint for users with 2FA enabled to generate a new set of single-use backup codes. This also requires password re-verification.",
            "dependencies": [
              "38.3"
            ],
            "details": "Create a `POST` endpoint at `/api/auth/2fa/backup-codes`. This route must be protected and check if `isTwoFactorEnabled` is `true`. The request body must include the user's current `password`. After verifying the password, first delete any existing backup codes for the user. Then, generate a new set of 10 unique, random codes (e.g., 8-10 alphanumeric characters). For each code, hash it using `bcrypt` and create a new record in the `BackupCode` table. Finally, return the array of *plaintext* codes to the user. This is the only time the user will see them.",
            "status": "done",
            "testStrategy": "For a user with 2FA enabled, send a POST request to `/backup-codes` with the correct password. Verify the response is a 200 OK and contains an array of plaintext codes. Check the `BackupCode` table to ensure 10 new, hashed codes associated with the user have been created. Call the endpoint again to verify the old codes are replaced with new ones."
          }
        ]
      },
      {
        "id": 39,
        "title": "Create UI Components for TOTP Two-Factor Authentication",
        "description": "Develop the necessary frontend components for managing TOTP-based 2FA. This includes a setup modal with a QR code, a verification form, a component to display backup codes, and a button to disable the feature.",
        "details": "This task involves creating the complete user interface for the TOTP two-factor authentication feature. All components should be built using React and shadcn/ui for a consistent look and feel.\n1. **2FA Status Component**: On the user's account settings page, create a section that displays the current 2FA status (Enabled/Disabled) and provides a button to either 'Enable 2FA' or 'Disable 2FA'.\n2. **Setup Modal**: When the 'Enable 2FA' button is clicked, a modal (`Dialog` from shadcn/ui) should appear. This modal will make a GET request to the `/api/auth/2fa/setup` endpoint (from Task 38) to fetch the QR code data URI and the secret key.\n   - Display the QR code as an image.\n   - Display the secret key as plain text for manual entry into an authenticator app.\n   - Include a form with a single input field for the 6-digit verification code.\n3. **Verification Form**: Use `react-hook-form` and `zod` (as established in Task 14) to validate the 6-digit code. On submission, this form will POST the code to the `/api/auth/2fa/verify` endpoint. Handle success and error responses from the API, showing appropriate feedback to the user.\n4. **Backup Codes Display**: Upon successful verification and enablement, the setup modal should be replaced with a view displaying the backup codes fetched from the `/api/auth/2fa/backup-codes` endpoint. This component must include a prominent warning to the user to store these codes securely. Implement 'Copy to Clipboard' and 'Download as .txt' functionality for the codes.\n5. **Disable 2FA Logic**: The 'Disable 2FA' button should trigger a confirmation modal. Upon confirmation, it will make a POST request to the `/api/auth/2fa/disable` endpoint to turn off 2FA for the user's account. The UI should update accordingly upon a successful response.",
        "testStrategy": "1. **Enablement Flow**: Navigate to the account settings page and click 'Enable 2FA'. Verify the setup modal appears and displays both a QR code and a secret key. Scan the QR code with an authenticator app. First, enter an incorrect 6-digit code and verify that an error message is displayed. Then, enter the correct code and verify that 2FA is enabled and the backup codes are shown.\n2. **Backup Codes Verification**: Confirm that the backup codes are displayed correctly. Test the 'Copy to Clipboard' button and the 'Download' button to ensure they function as expected.\n3. **Disablement Flow**: With 2FA enabled, click the 'Disable 2FA' button. Verify a confirmation prompt appears. After confirming, check that the UI updates to show 2FA as 'Disabled'.\n4. **API Interaction**: Use browser developer tools to monitor network requests. Ensure that the correct API endpoints (`/setup`, `/verify`, `/backup-codes`, `/disable`) are being called with the correct HTTP methods and that the frontend correctly handles both success (2xx) and error (4xx) responses.",
        "status": "pending",
        "dependencies": [
          38,
          14
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "Integrate TOTP Management into User Profile Page",
        "description": "Modify the existing user profile page to include a security section for managing two-factor authentication (2FA). This section will display the current TOTP status and provide options to enable or disable it.",
        "details": "Locate and update the main user profile or account settings page component. Add a new 'Security' section that fetches and displays the user's current 2FA status. Conditionally render an 'Enable 2FA' button or a 'Disable 2FA' button based on this status. Integrate the UI components from Task #39: the 'Enable' button should launch the setup modal (with QR code and verification form), and the 'Disable' button should trigger a confirmation dialog before calling the disable API endpoint from Task #38. Ensure the UI state updates correctly upon successful completion of these actions without a page refresh.",
        "testStrategy": "1. Log in as a user with 2FA disabled and navigate to the profile page. Verify the security section shows 'Disabled' status and an 'Enable' button. 2. Click 'Enable', complete the setup flow using the modal, and verify the page updates to show 'Enabled' status. 3. Refresh the page to ensure the new status persists. 4. Click the 'Disable' button, confirm the action, and verify the page updates back to 'Disabled' status. 5. Log out and log back in to confirm the TOTP code is no longer required.",
        "status": "pending",
        "dependencies": [
          38,
          39
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 41,
        "title": "Implement TOTP Verification in Login Flow",
        "description": "Modify the NextAuth.js login process to require a TOTP code for users with two-factor authentication enabled. This includes creating a verification page and updating the session state management.",
        "details": "This task integrates the second factor of authentication into the user login journey. 1. **Update Authentication Logic**: Modify the `authorize` callback in the NextAuth.js configuration. After successfully validating the user's password (Task 8), check if the user has 2FA enabled. If so, do not return the full user object immediately. Instead, return a partial object indicating that 2FA is required, for example: `{ id: user.id, isTwoFactorEnabled: true }`. 2. **Manage Intermediate Session State**: Adjust the `jwt` callback to handle this intermediate state. When the `authorize` callback returns the partial object, set a flag in the JWT, such as `isTwoFactorAuthenticated: false`. This token will grant access only to the TOTP verification page. 3. **Create TOTP Verification Page**: Develop a new route and page at `/auth/verify-totp`. This page will feature a form for users to input the 6-digit code from their authenticator app. Use a server action to handle the form submission securely. 4. **Implement Verification Action**: The server action will receive the TOTP code. It will retrieve the current user's session, fetch their 2FA secret from the database, and use the `otplib.verify()` function (from Task 37) to validate the code. 5. **Finalize Authentication**: If the code is valid, the server action must trigger a session update to finalize the login. This involves re-signing the JWT with `isTwoFactorAuthenticated: true` and then redirecting the user to their appropriate dashboard, respecting the role-based redirection logic from Task 28. If the code is invalid, the action should return an error message to the form. 6. **Update Middleware**: Enhance the `middleware.ts` (from Task 17) to protect routes from users in the intermediate 2FA state. The middleware should inspect the JWT; if a user is authenticated but `isTwoFactorAuthenticated` is false, it must redirect any requests for protected pages to `/auth/verify-totp`.",
        "testStrategy": "1. **Login without 2FA**: Log in as a user who does not have 2FA enabled. Verify that the login process is successful and proceeds directly to the dashboard without any intermediate steps. 2. **Login with 2FA (Success)**: Log in as a user with 2FA enabled. After submitting the correct password, verify that you are redirected to the `/auth/verify-totp` page. Enter the correct 6-digit code from an authenticator app and verify that you are successfully logged in and redirected to the appropriate dashboard. 3. **Login with 2FA (Failure)**: On the `/auth/verify-totp` page, submit an incorrect or expired TOTP code. Verify that an appropriate error message is displayed on the form and you are not logged in. 4. **Middleware Route Protection**: After entering the correct password but before entering the TOTP code, attempt to manually navigate to a protected URL (e.g., `/dashboard`). Verify that the middleware correctly intercepts the request and redirects you back to `/auth/verify-totp`. 5. **Session Integrity**: After a successful 2FA login, use browser developer tools to inspect the session object and confirm that it reflects a fully authenticated state.",
        "status": "done",
        "dependencies": [
          8,
          17,
          37
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Update NextAuth.js Callbacks for 2FA Pre-verification State",
            "description": "Modify the `authorize` and `jwt` callbacks in the NextAuth.js configuration. The `authorize` callback will check if a user has 2FA enabled after password validation. If so, it will signal the need for a second factor, and the `jwt` callback will create a token with an intermediate authentication state.",
            "dependencies": [],
            "details": "In `app/api/auth/[...nextauth]/route.ts`:\n1. In the `authorize` callback, after successfully validating the user's password, fetch the user's record including their 2FA status.\n2. If `user.isTwoFactorEnabled` is true, return a partial object like `{ id: user.id, isTwoFactorEnabled: true }` instead of the full user object.\n3. In the `jwt` callback, check if the `user` object from `authorize` contains `isTwoFactorEnabled`. \n4. If it does, set a flag in the JWT: `token.isTwoFactorAuthenticated = false`. Also, ensure `token.sub` is set to `user.id`.\n5. If it's a normal login (full user object), the token should reflect a fully authenticated state.",
            "status": "done",
            "testStrategy": "Log in as a user with 2FA enabled. After submitting the correct password, use browser developer tools to inspect the session token. Verify that the decoded JWT payload contains a property like `isTwoFactorAuthenticated: false`. Log in as a user without 2FA and verify this property is not present or is true."
          },
          {
            "id": 2,
            "title": "Create the TOTP Verification Page UI",
            "description": "Develop the user interface for the TOTP verification step. This will be a new page at `/auth/verify-totp` containing a form for the user to enter their 6-digit code from their authenticator app and an option to use a backup code.",
            "dependencies": [],
            "details": "1. Create a new route at `app/auth/verify-totp/page.tsx`.\n2. Implement a form using React Hook Form and a Zod schema for validation. The schema should accept a 6-digit numeric string.\n3. The form should include a single input field for the code, a 'Verify' submit button, and a link/button for users who need to use a backup code.\n4. The component should be a client component that calls a server action on form submission.\n5. Implement UI feedback for loading states and display error messages returned from the server action.",
            "status": "done",
            "testStrategy": "Navigate to `/auth/verify-totp`. Verify the form renders correctly. Test client-side validation by entering non-numeric characters or an incorrect number of digits. Ensure the form can be submitted."
          },
          {
            "id": 3,
            "title": "Implement Server Action for TOTP Code Verification",
            "description": "Create a server action to handle the submission from the TOTP verification page. This action will validate the provided code against the user's stored 2FA secret and update the session upon success.",
            "dependencies": [
              "41.1",
              "41.2"
            ],
            "details": "1. Create a new server action in a file like `actions/verify-totp.ts`.\n2. The action will receive the 6-digit code from the form.\n3. Use `auth()` from NextAuth.js to retrieve the current session token and confirm the user is in the intermediate state (`isTwoFactorAuthenticated === false`).\n4. Fetch the user's `twoFactorSecret` from the database using the user ID from the token.\n5. Use the `otplib.verify()` function (from Task 37) to validate the submitted code against the secret.\n6. If the code is valid, proceed to the session finalization step (covered in 41.5). If invalid, return an error object like `{ error: 'Invalid code' }`.",
            "status": "done",
            "testStrategy": "With a user in the intermediate 2FA state, call the server action with a valid TOTP code and verify it returns a success response. Call it with an invalid code and verify it returns the expected error message."
          },
          {
            "id": 4,
            "title": "Enhance Middleware to Enforce 2FA Verification Step",
            "description": "Modify the existing `middleware.ts` to protect application routes from users who have authenticated with their password but have not yet completed the TOTP verification step. It should redirect them to the verification page.",
            "dependencies": [
              "41.1"
            ],
            "details": "1. Open `middleware.ts`.\n2. In the middleware logic (e.g., within the `withAuth` callbacks), inspect the decoded JWT token.\n3. Add a new condition: if `token` exists but `token.isTwoFactorAuthenticated === false`:\n   a. Check if the current request path is `/auth/verify-totp`. If not, redirect the user to `/auth/verify-totp`.\n   b. Allow the request to proceed if the path is `/auth/verify-totp`.\n4. Ensure this logic does not interfere with the existing rule that redirects unauthenticated users to the login page.",
            "status": "done",
            "testStrategy": "Log in as a 2FA-enabled user. After password submission, attempt to navigate directly to a protected route like `/dashboard`. Verify you are redirected to `/auth/verify-totp`. Verify that you can access `/auth/verify-totp` without being redirected."
          },
          {
            "id": 5,
            "title": "Finalize Session and Implement Post-Verification Redirection",
            "description": "Upon successful TOTP verification, update the user's session to a fully authenticated state and redirect them to the appropriate dashboard page, respecting any role-based logic.",
            "dependencies": [
              "41.3"
            ],
            "details": "1. In the `actions/verify-totp.ts` server action, after a successful code validation:\n2. Call the `update` function from `next-auth/react` (or a similar server-side mechanism if available) to update the session token, setting `isTwoFactorAuthenticated: true`.\n3. After updating the session, determine the correct redirect URL (e.g., `/dashboard`). This may involve fetching the user's role to apply logic from Task 28.\n4. The server action should return a success object containing the redirect URL, e.g., `{ success: true, redirectUrl: '/dashboard' }`.\n5. The client-side form handler on the `/auth/verify-totp` page will use this URL to perform the redirection via `router.push()`.",
            "status": "done",
            "testStrategy": "Complete the entire login flow as a 2FA-enabled user (password then valid TOTP). Verify the session token is updated to a fully authenticated state and that you are redirected to the correct dashboard page."
          },
          {
            "id": 6,
            "title": "Implement Backup Code Verification in Login Flow",
            "description": "Extend the verification server action to accept one-time backup codes as an alternative to TOTP. A used backup code must be invalidated to prevent reuse.",
            "dependencies": [
              "41.3"
            ],
            "details": "1. In the `actions/verify-totp.ts` server action, if the `otplib.verify()` check fails, initiate a backup code check.\n2. Assume a `TwoFactorBackupCode` model exists, linked to the user, with a hashed `code` and a `usedAt` timestamp.\n3. Fetch all unused backup codes for the user from the database.\n4. Iterate through the fetched codes, using `bcrypt.compare()` to check the submitted code against each hashed code.\n5. If a match is found, update that backup code record in the database by setting the `usedAt` timestamp to the current time.\n6. Proceed with the session update and redirection logic from subtask 41.5 as if it were a successful TOTP verification.\n7. If both TOTP and backup code checks fail, return the 'Invalid code' error.",
            "status": "done",
            "testStrategy": "1. On the TOTP verification page, enter a valid, unused backup code. Verify login succeeds and the code is marked as used in the database. 2. Attempt to log in again using the same backup code and verify that it fails."
          }
        ]
      },
      {
        "id": 42,
        "title": "Implement Admin Panel for TOTP Configuration",
        "description": "Create an admin-level interface to manage global TOTP settings, such as code length and expiration time, and to enforce two-factor authentication for specific users.",
        "details": "This task involves creating a new section in the admin panel for managing the application's TOTP two-factor authentication settings. \n\n**Backend:**\n1. **Database Schema:** Create a new model, `TotpSettings`, to store global configuration. It should include fields like `codeLength` (INTEGER, default 6) and `expirationTime` (INTEGER, default 30 minutes in seconds). Also, add a boolean field `isTwoFactorForced` to the `User` model.\n2. **API Endpoints:** Create new API routes protected for admin users only. \n   - `GET /api/admin/totp-settings`: Fetches the current global TOTP settings.\n   - `PUT /api/admin/totp-settings`: Updates the global settings. It should validate inputs (e.g., length between 6-8, expiration time from a predefined list).\n   - `POST /api/admin/users/:userId/force-2fa`: Sets the `isTwoFactorForced` flag for a specific user.\n3. **Service Layer:** Modify the TOTP utility service created in Task #37 to read from the new `TotpSettings` model. The functions for generating and verifying tokens must use the configured code length and expiration time instead of hardcoded values.\n4. **Login Flow:** Update the authentication logic from Task #41. If a user has `isTwoFactorForced` set to true but has not yet enabled 2FA, they must be redirected to the 2FA setup page after logging in with their password, and they should not be able to access any other part of the application until setup is complete.\n\n**Frontend:**\n1. **Admin UI:** Create a new page or section in the admin dashboard titled 'Two-Factor Authentication Settings'.\n2. **Global Settings Form:** This form should display the current settings and allow an admin to select a code length (dropdown: 6, 7, 8) and an expiration time (dropdown: 5, 10, 15, 30 minutes). A 'Save' button will submit the changes to the PUT endpoint.\n3. **User Management Integration:** In the existing user management table within the admin panel, add a new column or control (e.g., a toggle switch) to show and change the 'Force 2FA' status for each user.",
        "testStrategy": "1. **Admin Access Control:** Log in as a non-admin user and attempt to access the new admin API endpoints directly (e.g., using Postman or browser console). Verify that all requests are rejected with a 403 Forbidden status.\n2. **Global Settings UI:** Log in as an admin. Navigate to the TOTP settings page. Change the code length to 8 and the expiration to 10 minutes. Save the changes. Refresh the page and verify the form retains the new values. Check the database to confirm the `TotpSettings` table is updated.\n3. **Force 2FA Functionality:** As an admin, find a user who has not enabled 2FA and toggle the 'Force 2FA' switch for them. Log out and log in as that user. Verify that after entering their password, they are immediately redirected to the 2FA setup page and cannot proceed further until it is completed.\n4. **End-to-End Verification:** After setting the code length to 8 via the admin panel, have a new user (or the 'forced' user) complete the 2FA setup. Verify their authenticator app generates an 8-digit code. Test the login flow to ensure the 8-digit code is accepted.",
        "status": "pending",
        "dependencies": [
          37,
          38,
          41
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 43,
        "title": "Implement Global System Settings for TOTP",
        "description": "Create a `SystemSettings` model to store global TOTP configuration, develop a secure API endpoint for administrators to manage these settings, and build a corresponding user interface within the admin panel.",
        "details": "This task involves creating the infrastructure for centrally managing TOTP parameters. 1. **Database Schema:** Define a new singleton model in `schema.prisma` called `SystemSettings`. It should include fields like `id`, `totpIssuer` (String, the name displayed in authenticator apps), `totpDigits` (Int, e.g., 6 or 8), and `totpPeriod` (Int, e.g., 30 or 60 seconds). Apply the migration. 2. **API Endpoint:** Create a new API route at `/api/admin/settings/totp`. Implement a `GET` handler to fetch the current settings (creating default values if none exist) and a `PUT` handler to update them. Both handlers must be protected, ensuring only users with an 'ADMIN' role can access them. Use Zod for validating the input on the `PUT` request. 3. **Admin UI Page:** Develop a new page at `/admin/settings/totp`. This page will contain a form built with `react-hook-form` and `shadcn/ui` components. The form will fetch and display the current settings on load and submit updated values to the API endpoint, providing user feedback via toast notifications.",
        "testStrategy": "1. **API Security:** Using an API client, attempt to access the `GET` and `PUT` endpoints at `/api/admin/settings/totp` as a non-authenticated user and as an authenticated non-admin user. Verify all requests are rejected with appropriate 401/403 status codes. 2. **API Functionality:** As an admin, send a `PUT` request with valid data to update the settings and verify a 200 OK response. Follow up with a `GET` request to confirm the changes were persisted. Test the `PUT` endpoint with invalid data (e.g., non-integer for digits) to ensure a 400 Bad Request response is returned. 3. **UI Verification:** Log in as an admin and navigate to the new settings page. Confirm the form is populated with the correct data. Update the settings, save, and verify a success message is shown. Refresh the page to ensure the new values persist. Attempt to access the page as a non-admin user and confirm access is denied.",
        "status": "done",
        "dependencies": [
          38
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 44,
        "title": "Implementar Migración y Recopilación de DNI para Usuarios",
        "description": "Añadir un campo DNI al modelo de usuario, implementar un flujo para que los usuarios existentes lo proporcionen, y actualizar los formularios de registro y administración para incluir este nuevo dato.",
        "details": "Esta tarea se divide en varias partes clave para asegurar una transición completa. 1. **Actualización del Esquema de Base de Datos**: Modificar el archivo `schema.prisma` para añadir un campo opcional y único para el DNI en el modelo `User`. Ejemplo: `dni String? @unique`. Ejecutar la migración con `npx prisma migrate dev --name add_dni_to_user`. 2. **Actualización del Perfil de Usuario**: En la página de perfil del usuario, añadir una sección o formulario visible solo si el DNI del usuario no está definido. Este formulario debe enviar los datos a un endpoint de API seguro (ej. `PUT /api/user/profile`) que valide el formato del DNI usando Zod antes de guardarlo. 3. **Flujo de Migración Forzada**: Modificar el middleware de rutas protegidas (`middleware.ts`). El middleware deberá verificar si el usuario autenticado tiene un DNI registrado. Si no lo tiene, se le redirigirá forzosamente a la página de perfil para que lo complete, bloqueando el acceso a otras áreas de la aplicación hasta que se cumpla el requisito. 4. **Integración en Registro y Administración**: Actualizar el formulario de registro de nuevos usuarios para que el campo DNI sea obligatorio. Modificar el panel de administración de usuarios para mostrar el DNI en el listado y permitir a los administradores ver y editar este campo para cualquier usuario.",
        "testStrategy": "1. **Verificación de Migración**: Tras ejecutar la migración, inspeccionar la base de datos para confirmar que la columna `dni` existe en la tabla `User` y permite valores nulos. 2. **Pruebas de Perfil de Usuario**: Iniciar sesión como un usuario existente sin DNI. Verificar que se muestra el formulario para añadirlo. Introducir un DNI válido y confirmar que se guarda correctamente y el formulario desaparece. Intentar con un formato inválido y verificar que se muestra un mensaje de error. 3. **Pruebas del Middleware de Redirección**: Iniciar sesión como un usuario sin DNI y verificar la redirección forzada a la página de perfil. Intentar acceder a otras rutas protegidas (ej. `/dashboard`) y confirmar que la redirección persiste. Tras añadir el DNI, verificar que se recupera el acceso normal a la aplicación. 4. **Pruebas de Registro**: Intentar registrar un nuevo usuario sin DNI y verificar que el proceso falla con un error de validación. Completar un registro con un DNI válido y confirmar que el usuario se crea correctamente con el DNI asignado. 5. **Pruebas del Panel de Administración**: Como administrador, navegar a la gestión de usuarios. Verificar que la columna DNI es visible. Editar un usuario para añadir/modificar su DNI y confirmar que los cambios se guardan.",
        "status": "pending",
        "dependencies": [
          7,
          8,
          17,
          25
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 45,
        "title": "Comprehensive Testing and Documentation for TOTP Feature",
        "description": "Conduct exhaustive end-to-end testing of all TOTP user and admin flows, create comprehensive technical and user-facing documentation, and develop automated test scripts for various TOTP configurations.",
        "details": "This task serves as the final quality assurance and documentation step for the entire TOTP feature. It is divided into three main areas: testing, documentation, and automation. 1. **Exhaustive End-to-End Testing**: Manually test all user stories related to TOTP. This includes: the user flow for enabling 2FA via their profile (QR code generation, verification), the login process for a 2FA-enabled user (prompt for code, validation), the user flow for disabling 2FA, and the login process for non-2FA users (no change). Also, test all admin functionalities, including modifying global TOTP settings (issuer, digits, period) and verifying that these changes are reflected in the user experience. 2. **Documentation Creation**: Produce two sets of documentation. First, a user-facing guide explaining what TOTP is, how to set it up with common authenticator apps, and how to use it. This should be non-technical and include screenshots. Second, create detailed technical documentation for developers, including API specifications for all new TOTP-related endpoints, sequence diagrams for the login and setup flows, and notes on the database schema changes. 3. **Automated Test Scripts**: Using a framework like Cypress or Playwright, develop a suite of automated tests covering the critical paths. This should include scripts for a user enabling 2FA, logging out, logging back in successfully, and disabling 2FA. Another script should cover an admin changing global settings and a user then attempting to set up 2FA to confirm the new settings are applied.",
        "testStrategy": "1. **Test Case Execution**: All manual test cases derived from the details section must be executed against a staging environment. A test report must be generated and show a 100% pass rate for all critical flows. 2. **Documentation Review**: The user documentation must be reviewed and approved by a non-technical stakeholder for clarity. The technical documentation must be peer-reviewed by another developer for accuracy and completeness. 3. **Automation Suite**: The automated test scripts must be run successfully in a CI/CD pipeline. The pull request containing the test scripts must be reviewed and merged. 4. **Cross-Configuration Verification**: Manually verify that the login and setup flows work correctly with different admin-defined configurations (e.g., 8-digit codes, 60-second periods).",
        "status": "pending",
        "dependencies": [
          40,
          41,
          42,
          43
        ],
        "priority": "low",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-21T22:19:07.747Z",
      "updated": "2025-10-01T21:45:54.385Z",
      "description": "Tasks for master context"
    }
  },
  "admin-section-tasks": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Next.js Project with TypeScript",
        "description": "Initialize a new Next.js project with TypeScript and set up the basic project structure.",
        "details": "Use `create-next-app` with the App Router and TypeScript template. \n```bash\nnpx create-next-app@latest my-auth-app --typescript --eslint --tailwind --src-dir --app --import-alias \"@/*\"\ncd my-auth-app\n```\nEnsure basic linting and formatting tools are configured.",
        "testStrategy": "Verify that the Next.js application runs successfully in development mode (`npm run dev`). Check that TypeScript compilation works without errors.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Setup Prisma ORM and PostgreSQL Database",
        "description": "Install and configure Prisma ORM with a PostgreSQL database. Define the initial User schema.",
        "details": "Install Prisma CLI and Client: `npm install prisma --save-dev` and `npm install @prisma/client`. \nInitialize Prisma: `npx prisma init --datasource-provider postgresql`. \nConfigure `DATABASE_URL` in `.env`. \nDefine User model in `prisma/schema.prisma`:\n```prisma\nmodel User {\n  id        String   @id @default(cuid())\n  email     String   @unique\n  name      String?\n  password  String\n  emailVerified DateTime? // To store verification timestamp\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n```\nRun `npx prisma migrate dev --name init` to create the initial migration and apply it.",
        "testStrategy": "Verify that Prisma can connect to the PostgreSQL database. Check that the `User` table is created in the database with the correct columns after running migrations.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Install and Configure NextAuth.js",
        "description": "Install and configure NextAuth.js for session management and authentication providers.",
        "details": "Install NextAuth.js: `npm install next-auth`. \nCreate `app/api/auth/[...nextauth]/route.ts`. \nConfigure NextAuth with a Credentials provider. \n```typescript\n// app/api/auth/[...nextauth]/route.ts\nimport NextAuth from 'next-auth';\nimport CredentialsProvider from 'next-auth/providers/credentials';\n// ... (import Prisma adapter and bcrypt later)\n\nexport const authOptions = {\n  providers: [\n    CredentialsProvider({\n      name: 'Credentials',\n      credentials: {\n        email: { label: \"Email\", type: \"text\" },\n        password: { label: \"Password\", type: \"password\" }\n      },\n      async authorize(credentials) {\n        // Logic to verify credentials will be added in later tasks\n        // For now, can return null or a mock user for setup\n        if (credentials?.email && credentials?.password) {\n          // Placeholder: Actual DB lookup and password check later\n          // const user = await prisma.user.findUnique({ where: { email: credentials.email } });\n          // if (user && await bcrypt.compare(credentials.password, user.password)) return user;\n          return null; \n        }\n        return null;\n      }\n    })\n  ],\n  // session: { strategy: 'jwt' }, // Optional: JWT strategy\n  // pages: { signIn: '/login' }, // Optional: Custom login page\n};\n\nconst handler = NextAuth(authOptions);\nexport { handler as GET, handler as POST };\n```\nWrap the root layout with `<SessionProvider>` from `next-auth/react`.",
        "testStrategy": "Verify that the NextAuth.js API route is accessible (e.g., `/api/auth/signin`). Check for any console errors related to NextAuth.js setup.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Setup shadcn/ui for UI Components",
        "description": "Install and set up shadcn/ui for reusable UI components.",
        "details": "Follow the shadcn/ui installation guide for Next.js: `npx shadcn-ui@latest init`. \nConfigure `tailwind.config.js` and `globals.css` as per shadcn/ui documentation. \nInstall basic components like `button`, `input`, `label`, `card`:\n`npx shadcn-ui@latest add button input label card form`.",
        "testStrategy": "Verify that shadcn/ui components can be imported and rendered correctly in a sample page. Check that Tailwind CSS styles are applied.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Install Zod for Validation",
        "description": "Install Zod for schema validation.",
        "details": "Install Zod: `npm install zod`. No specific configuration needed beyond installation. It will be used in API routes and potentially forms.",
        "testStrategy": "Create a simple Zod schema and test its validation logic in a test file or a temporary route. Ensure type inference works correctly.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Setup Email Sending Service (Resend/Nodemailer)",
        "description": "Install and configure an email sending service (Resend or Nodemailer).",
        "details": "Choose between Resend or Nodemailer. For Resend: `npm install resend`. \nGet API key from Resend and add it to `.env` (e.g., `RESEND_API_KEY`). \nCreate a utility function for sending emails, e.g., `lib/email.ts`.\n```typescript\n// lib/email.ts\nimport { Resend } from 'resend';\n\nconst resend = new Resend(process.env.RESEND_API_KEY);\n\nexport const sendVerificationEmail = async (email: string, token: string) => {\n  const verificationLink = `${process.env.NEXT_PUBLIC_APP_URL}/api/auth/verify-email?token=${token}`;\n  await resend.emails.send({\n    from: 'onboarding@resend.dev', // Replace with your domain\n    to: email,\n    subject: 'Verify your email address',\n    html: `<p>Click <a href=\"${verificationLink}\">here</a> to verify your email.</p>`\n  });\n};\n```\nEnsure `NEXT_PUBLIC_APP_URL` is set in `.env` (e.g., `http://localhost:3000`).",
        "testStrategy": "Send a test email to a controlled email address using the configured service. Verify that the email is received and the content is correct.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement User Registration API Endpoint",
        "description": "Implement the user registration API endpoint, including email/password validation with Zod and password hashing.",
        "details": "Create an API route `app/api/auth/register/route.ts`. \nUse Zod to validate `email` and `password`. \nInstall bcrypt: `npm install bcryptjs` and `@types/bcryptjs`. \nHash the password using bcrypt before saving to the database. \nCheck if user already exists. \n```typescript\n// app/api/auth/register/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { z } from 'zod';\nimport bcrypt from 'bcryptjs';\nimport prisma from '@/lib/prisma'; // Assuming prisma client is exported from lib/prisma\n\nconst registerSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(8),\n});\n\nexport async function POST(req: NextRequest) {\n  try {\n    const body = await req.json();\n    const { email, password } = registerSchema.parse(body);\n\n    const existingUser = await prisma.user.findUnique({ where: { email } });\n    if (existingUser) {\n      return NextResponse.json({ error: 'User already exists' }, { status: 400 });\n    }\n\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const user = await prisma.user.create({\n      data: { email, password: hashedPassword },\n    });\n    // Email verification sending will be handled in a subsequent task\n    return NextResponse.json({ message: 'User registered successfully. Please verify your email.' }, { status: 201 });\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return NextResponse.json({ error: error.errors }, { status: 400 });\n    }\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });\n  }\n}\n```",
        "testStrategy": "Test the endpoint with valid and invalid data (e.g., malformed email, short password). Verify that new users are created in the database with hashed passwords and appropriate error responses are returned.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement User Login Logic in NextAuth.js",
        "description": "Implement the user login API endpoint within NextAuth.js `authorize` function, including email/password validation and password comparison.",
        "details": "Update the `authorize` function in `app/api/auth/[...nextauth]/route.ts`. \nUse Prisma to find the user by email. \nUse bcrypt to compare the provided password with the stored hashed password. \nReturn the user object if credentials are valid, otherwise return null. \n```typescript\n// app/api/auth/[...nextauth]/route.ts (update authorize function)\n// ... imports (prisma, bcrypt)\nasync authorize(credentials) {\n  if (!credentials?.email || !credentials?.password) return null;\n\n  const user = await prisma.user.findUnique({\n    where: { email: credentials.email },\n  });\n\n  if (!user || !user.password) return null;\n  // Add check for emailVerified status after verification flow is implemented\n  // if (!user.emailVerified) { throw new Error('Please verify your email before logging in.'); }\n\n  const isValidPassword = await bcrypt.compare(credentials.password, user.password);\n  if (!isValidPassword) return null;\n\n  return { id: user.id, email: user.email, name: user.name, emailVerified: user.emailVerified }; // Return necessary user fields for session\n}\n// ... rest of authOptions\n```\nEnsure NextAuth.js is configured to use Prisma Adapter if you want database sessions: `npm install @next-auth/prisma-adapter`. Then add `adapter: PrismaAdapter(prisma)` to `authOptions`.",
        "testStrategy": "Test login with valid and invalid credentials. Verify that NextAuth.js creates a session cookie upon successful login. Check that users who are not verified (once that logic is in) cannot log in.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          5,
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement User Logout Functionality",
        "description": "Implement user logout functionality using NextAuth.js `signOut` method.",
        "details": "Use the `signOut` function from `next-auth/react` in a UI component (e.g., a logout button). \n```typescript\n// Example in a component\nimport { signOut } from 'next-auth/react';\n\nconst LogoutButton = () => {\n  return <button onClick={() => signOut({ callbackUrl: '/' })}>Sign Out</button>;\n};\n```\nNo backend API changes are typically needed as NextAuth.js handles this via its routes.",
        "testStrategy": "Log in as a user, then click the logout button. Verify that the session is terminated and the user is redirected (e.g., to the homepage).",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Email Verification Token Generation and Storage",
        "description": "Implement logic to generate and store email verification tokens. This might involve adding a new model or fields to the User model.",
        "details": "Create a new Prisma model for verification tokens or add fields to the User model. A separate model is cleaner for managing token expiry.\n```prisma\n// prisma/schema.prisma (add this model)\nmodel VerificationToken {\n  id        String   @id @default(cuid())\n  identifier String   // Typically user's email or ID\n  token     String   @unique\n  expires   DateTime\n\n  @@unique([identifier, token])\n}\n```\nRun `npx prisma migrate dev --name add_verification_token`. \nCreate a utility function to generate a unique token (e.g., using `crypto.randomBytes`). Store the token with an expiry date linked to the user.",
        "testStrategy": "Verify that tokens can be generated, stored in the database with an expiry, and retrieved. Test uniqueness constraints.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Send Verification Email on Registration",
        "description": "Modify the registration process to generate a verification token and send a verification email to the new user.",
        "details": "In `app/api/auth/register/route.ts`, after successfully creating the user (but before they can log in, or mark them as unverified):\n1. Generate a verification token using the utility from task 10.\n2. Store the token associated with the user's email/ID.\n3. Use the email sending utility (task 6) to send an email containing a link with this token. The link should point to an API endpoint for verification (task 12).\n```typescript\n// In app/api/auth/register/route.ts, after user creation:\n// ...\nconst verificationToken = crypto.randomBytes(32).toString('hex');\nconst expires = new Date(Date.now() + 3600 * 1000); // 1 hour expiry\n\nawait prisma.verificationToken.create({\n  data: {\n    identifier: user.email, // or user.id\n    token: verificationToken,\n    expires,\n  },\n});\n\nawait sendVerificationEmail(user.email, verificationToken);\n// ...\n```\nUser's `emailVerified` field should initially be null or false.",
        "testStrategy": "Register a new user. Verify that a verification token is created in the database. Verify that an email is sent to the user's email address with a correctly formatted verification link.",
        "priority": "high",
        "dependencies": [
          7,
          6,
          10
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Email Verification API Endpoint",
        "description": "Create an API endpoint to handle email verification. This endpoint will receive the token, validate it, and mark the user's email as verified.",
        "details": "Create `app/api/auth/verify-email/route.ts`. \nThis GET endpoint will take the `token` as a query parameter. \n1. Find the token in the `VerificationToken` table. \n2. Check if it's valid and not expired. \n3. If valid, find the associated user and update their `emailVerified` status/timestamp in the `User` table. \n4. Delete the used token. \n5. Redirect the user to the login page or a success page. \n```typescript\n// app/api/auth/verify-email/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport prisma from '@/lib/prisma';\n\nexport async function GET(req: NextRequest) {\n  const token = req.nextUrl.searchParams.get('token');\n  if (!token) {\n    return NextResponse.redirect(new URL('/?error=MissingToken', req.url));\n  }\n\n  const verificationToken = await prisma.verificationToken.findUnique({\n    where: { token },\n  });\n\n  if (!verificationToken || verificationToken.expires < new Date()) {\n    return NextResponse.redirect(new URL('/?error=InvalidOrExpiredToken', req.url));\n  }\n\n  await prisma.user.update({\n    where: { email: verificationToken.identifier }, // Assuming identifier is email\n    data: { emailVerified: new Date() },\n  });\n\n  await prisma.verificationToken.delete({ where: { id: verificationToken.id } });\n\n  return NextResponse.redirect(new URL('/login?verified=true', req.url));\n}\n```",
        "testStrategy": "Generate a verification link (manually or via registration). Click the link. Verify that the user's `emailVerified` status is updated in the database and the token is deleted. Test with invalid/expired tokens.",
        "priority": "high",
        "dependencies": [
          2,
          10
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Block Login for Unverified Emails",
        "description": "Update login logic to prevent users from logging in if their email is not verified.",
        "details": "In `app/api/auth/[...nextauth]/route.ts`, within the `authorize` function, add a check for `user.emailVerified` before returning the user object.\n```typescript\n// In authorize function of NextAuth options:\n// ...\n  const user = await prisma.user.findUnique({ where: { email: credentials.email } });\n  if (!user || !user.password) return null;\n\n  if (!user.emailVerified) {\n    // Option 1: Return null to indicate login failure\n    // return null; \n    // Option 2: Throw a specific error that can be caught by NextAuth and displayed to user\n    throw new Error('EmailNotVerified'); \n  }\n// ... rest of password check and return user\n```\nHandle the `EmailNotVerified` error on the client-side if using the error throwing approach.",
        "testStrategy": "Attempt to log in with a user account that has been registered but not yet verified. Verify that login fails and an appropriate message is shown. Then, verify the email and attempt login again; it should succeed.",
        "priority": "medium",
        "dependencies": [
          8,
          12
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Create Reusable Auth Form Components",
        "description": "Create reusable React components for authentication forms (Registration, Login) using shadcn/ui and Zod for client-side validation.",
        "details": "Create components like `AuthForm.tsx`, `RegistrationForm.tsx`, `LoginForm.tsx`. \nUse shadcn/ui components (`Input`, `Button`, `Label`, `Card`, `Form`). \nIntegrate Zod for client-side form validation using libraries like `react-hook-form` with its Zod resolver (`@hookform/resolvers/zod`). \n```typescript\n// Example structure for LoginForm.tsx\n'use client';\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport * as z from 'zod';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';\nimport { signIn } from 'next-auth/react';\nimport { useRouter } from 'next/navigation';\n\nconst loginSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(1, 'Password is required'),\n});\n\nexport function LoginForm() {\n  const router = useRouter();\n  const form = useForm<z.infer<typeof loginSchema>>({\n    resolver: zodResolver(loginSchema),\n    defaultValues: { email: '', password: '' },\n  });\n\n  async function onSubmit(values: z.infer<typeof loginSchema>) {\n    const result = await signIn('credentials', {\n      redirect: false,\n      email: values.email,\n      password: values.password,\n    });\n    if (result?.ok) {\n      router.push('/dashboard'); // Or desired redirect path\n    } else {\n      // Handle error (e.g., display message from result.error)\n      form.setError('root', { message: result?.error || 'Login failed' });\n    }\n  }\n\n  return (\n    <Form {...form}>\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n        {/* FormFields for email and password */}\n        <Button type=\"submit\">Login</Button>\n      </form>\n    </Form>\n  );\n}\n```\nSimilarly create `RegistrationForm.tsx` that calls the `/api/auth/register` endpoint.",
        "testStrategy": "Verify that forms render correctly. Test client-side validation with Zod (e.g., empty fields, invalid email format). Ensure form submission calls the correct API endpoints.",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Develop User Registration Page",
        "description": "Develop the User Registration page (`/register`) using the created form components.",
        "details": "Create a Next.js page route `app/register/page.tsx`. \nImport and use the `RegistrationForm` component. \nHandle form submission, API responses, and display success/error messages to the user. \nRedirect or guide user on successful registration (e.g., message to check email).",
        "testStrategy": "Navigate to the `/register` page. Test the registration flow end-to-end. Verify UI feedback for successful registration and for errors (e.g., user already exists, validation errors).",
        "priority": "high",
        "dependencies": [
          14,
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Develop User Login Page",
        "description": "Develop the User Login page (`/login`) using the created form components.",
        "details": "Create a Next.js page route `app/login/page.tsx`. \nImport and use the `LoginForm` component. \nHandle form submission using `signIn` from `next-auth/react`. \nRedirect user to a protected page (e.g., `/dashboard`) on successful login. Display error messages on login failure.",
        "testStrategy": "Navigate to the `/login` page. Test login with valid and invalid credentials. Verify redirection on successful login and error messages on failure. Test login for unverified users (should fail with message).",
        "priority": "high",
        "dependencies": [
          14,
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Implement Protected Routes Middleware",
        "description": "Implement middleware to protect specific routes (e.g., `/dashboard`) from unauthenticated access using NextAuth.js.",
        "details": "Create `middleware.ts` in the root or `src` directory. \nUse `withAuth` HOF from `next-auth/middleware` or check `getToken` from `next-auth/jwt`. \n```typescript\n// middleware.ts\nexport { default } from \"next-auth/middleware\"\n\nexport const config = {\n  matcher: ['/dashboard/:path*', '/profile'], // Add all routes to protect\n};\n```\nAlternatively, for more complex logic:\n```typescript\n// middleware.ts\nimport { getToken } from 'next-auth/jwt';\nimport { NextRequest, NextResponse } from 'next/server';\n\nexport async function middleware(req: NextRequest) {\n  const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });\n\n  if (req.nextUrl.pathname.startsWith('/dashboard')) {\n    if (!token) {\n      const loginUrl = new URL('/login', req.url);\n      loginUrl.searchParams.set('callbackUrl', req.nextUrl.pathname);\n      return NextResponse.redirect(loginUrl);\n    }\n    // Add role-based checks if needed: if (token.role !== 'admin') return NextResponse.redirect('/');\n  }\n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: ['/dashboard/:path*', '/profile'],\n};\n```\nEnsure `NEXTAUTH_SECRET` is set in `.env`.",
        "testStrategy": "Attempt to access a protected route (e.g., `/dashboard`) without being logged in; verify redirection to the login page. Log in and access the protected route; verify access is granted.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Create Sample Dashboard Page (Protected)",
        "description": "Create a sample protected page (e.g., `/dashboard`) that displays user information and a logout button.",
        "details": "Create `app/dashboard/page.tsx`. \nUse `useSession` hook from `next-auth/react` to access session data and display user information (e.g., email). \nInclude the `LogoutButton` component (from task 9). \nThis page should only be accessible to authenticated users due to the middleware (task 17).",
        "testStrategy": "Log in and navigate to `/dashboard`. Verify that user-specific information is displayed. Test the logout button from this page. Attempt to access `/dashboard` when logged out and verify redirection.",
        "priority": "medium",
        "dependencies": [
          17,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Add Password Reset Token Model to Prisma Schema",
        "description": "Update the Prisma schema to include a model for storing password reset tokens. The model should include fields for an identifier (email), the token itself, and an expiration date.",
        "details": "Modify the `prisma/schema.prisma` file to add a new `PasswordResetToken` model. This model will store the necessary information for password reset functionality.\n\nThe model definition should be as follows:\n```prisma\nmodel PasswordResetToken {\n  id        String   @id @default(cuid())\n  email     String   // User's email address associated with the token\n  token     String   @unique // The cryptographically secure reset token\n  expires   DateTime // The timestamp when this token will expire\n\n  // Optional: If you need to quickly find tokens by email, consider adding an index:\n  // @@index([email])\n}\n```\nAfter adding the model to `prisma/schema.prisma`, run the following Prisma commands in your terminal:\n1. To create and apply a new migration: `npx prisma migrate dev --name add_password_reset_token_model`\n2. To regenerate the Prisma Client to include the new model: `npx prisma generate`\nThis will update your database schema and make the `PasswordResetToken` model available in your Prisma Client for database operations.",
        "testStrategy": "1. After defining the model in `prisma/schema.prisma`, run `npx prisma migrate dev --name add_password_reset_token_model`. Verify that the migration applies successfully without errors.\n2. Run `npx prisma generate` to update the Prisma Client.\n3. Inspect your PostgreSQL database (e.g., using `psql` or a database GUI tool) to confirm that a new table named `PasswordResetToken` has been created.\n4. Verify that the `PasswordResetToken` table has the following columns with appropriate types: `id` (String, Primary Key), `email` (String), `token` (String, Unique), `expires` (DateTime).\n5. Write a temporary test script or use a tool like Prisma Studio (`npx prisma studio`) to interact with the new table:\n    a. Attempt to create a new record in the `PasswordResetToken` table with valid data. Verify success.\n    b. Attempt to create a second record with the same `token` value as the first. Verify that this operation fails due to the unique constraint on the `token` field.\n    c. Attempt to create a second record with a different `token` but the same `email`. Verify success (as `email` is not unique by itself).\n    d. Read the created records to ensure data integrity.\n    e. Delete the test records.",
        "status": "done",
        "dependencies": [
          2,
          10
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Implement Password Reset Request API Endpoint",
        "description": "Create an API endpoint to handle password reset requests. This endpoint will receive a user's email, generate a secure password reset token, save it to the database with an expiration date, and send an email to the user with a link to reset their password.",
        "details": "Create a new API route at `app/api/auth/request-password-reset/route.ts` to handle POST requests.\n1.  **Input Validation**: The endpoint should expect a JSON body containing an `email` field. Use Zod for validating the email format.\n2.  **User Lookup**: Query the database using Prisma to find a user matching the provided email.\n3.  **Token Generation**:\n    *   If a user is found, generate a cryptographically secure, unique token (e.g., using `crypto.randomBytes(32).toString('hex')`).\n    *   Define an expiration period for the token (e.g., 1 hour from the current time).\n4.  **Token Storage**:\n    *   Before saving a new token, check for and invalidate/delete any existing, non-expired password reset tokens for the same email in the `PasswordResetToken` table to ensure only one active reset link per user.\n    *   Store the new token, the user's email, and its expiration timestamp in the `PasswordResetToken` table (defined in Task 19).\n5.  **Email Notification**:\n    *   Construct the password reset URL (e.g., `YOUR_APP_URL/reset-password?token=<GENERATED_TOKEN>`).\n    *   Send an email to the user's email address containing this unique password reset link. This requires an email sending service (e.g., Resend, Nodemailer) to be configured. The email should clearly state the purpose of the link and its expiration.\n6.  **Security Consideration**: To prevent user enumeration, the API should always return a generic success message (e.g., \"If an account with that email exists, a password reset link has been sent.\"), regardless of whether the email was found in the database or an error occurred during email sending (unless it's a client-side validation error). Log internal errors for monitoring.\n7.  **Error Handling**: Implement try-catch blocks for database operations and email sending. Log errors server-side.\n\nExample structure for the route handler:\n```typescript\n// app/api/auth/request-password-reset/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { z } from 'zod';\nimport prisma from '@/lib/prisma'; // Assuming prisma client\nimport crypto from 'crypto';\n// import { sendPasswordResetEmail } from '@/lib/email'; // Assume an email sending utility\n\nconst requestPasswordResetSchema = z.object({\n  email: z.string().email({ message: 'Invalid email address' }),\n});\n\nexport async function POST(req: NextRequest) {\n  try {\n    const body = await req.json();\n    const validation = requestPasswordResetSchema.safeParse(body);\n\n    if (!validation.success) {\n      return NextResponse.json({ errors: validation.error.flatten().fieldErrors }, { status: 400 });\n    }\n\n    const { email } = validation.data;\n\n    const user = await prisma.user.findUnique({\n      where: { email },\n    });\n\n    if (user) {\n      // Invalidate old tokens for this email\n      await prisma.passwordResetToken.deleteMany({\n        where: { email: email },\n      });\n\n      const token = crypto.randomBytes(32).toString('hex');\n      const expires = new Date(Date.now() + 3600 * 1000); // 1 hour from now\n\n      await prisma.passwordResetToken.create({\n        data: {\n          email,\n          token,\n          expires,\n        },\n      });\n\n      // const resetLink = `${process.env.NEXTAUTH_URL}/reset-password?token=${token}`;\n      // await sendPasswordResetEmail(email, resetLink); // Implement this function\n    }\n\n    // Always return a generic success message to prevent user enumeration\n    return NextResponse.json({ message: 'If your email is in our system, you will receive a password reset link.' }, { status: 200 });\n\n  } catch (error) {\n    console.error('Password reset request error:', error);\n    // Return generic message even on server error for security, but log it\n    return NextResponse.json({ message: 'If your email is in our system, you will receive a password reset link.' }, { status: 200 });\n  }\n}\n```",
        "testStrategy": "1.  **Successful Request**:\n    *   Send a POST request to `/api/auth/request-password-reset` with the email of an existing, registered user.\n    *   **Expected**: HTTP 200 OK response with a generic success message.\n    *   **Verification**:\n        *   Check the `PasswordResetToken` table in the database: a new record should exist for the user's email, containing a unique token and an expiration timestamp approximately 1 hour in the future.\n        *   (If email sending is mocked/testable) Verify that an email was dispatched to the user's address containing a link like `YOUR_APP_URL/reset-password?token=<TOKEN_VALUE>`.\n2.  **Non-Existent User Email**:\n    *   Send a POST request with an email address not registered in the system.\n    *   **Expected**: HTTP 200 OK response with the same generic success message (to prevent user enumeration).\n    *   **Verification**:\n        *   Check the `PasswordResetToken` table: no new token should be generated for this email.\n        *   No email should be sent.\n3.  **Invalid Email Format**:\n    *   Send a POST request with an invalid email format (e.g., \"testuser\", \"test@.com\").\n    *   **Expected**: HTTP 400 Bad Request response with a JSON body detailing the validation errors (e.g., `{ \"errors\": { \"email\": [\"Invalid email address\"] } }`).\n4.  **Missing Email Field**:\n    *   Send a POST request with an empty body or a body missing the `email` field.\n    *   **Expected**: HTTP 400 Bad Request response with a JSON body detailing the validation errors.\n5.  **Token Invalidation on Subsequent Request**:\n    *   Request a password reset for a user. Verify a token (Token A) is created.\n    *   Request another password reset for the same user.\n    *   **Expected**: HTTP 200 OK.\n    *   **Verification**:\n        *   Check the `PasswordResetToken` table: Token A should be deleted or marked as invalid. A new token (Token B) should be present and active for the user.\n6.  **Database/Service Error Simulation (if possible)**:\n    *   Simulate a database write failure or email sending failure (if these can be mocked).\n    *   **Expected**: The endpoint should still ideally return a generic success message (HTTP 200) to the client to prevent information leakage, but log the internal error server-side for administrators.",
        "status": "done",
        "dependencies": [
          2,
          19
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Create 'Forgot Password' Page",
        "description": "Develop the 'Forgot Password' page (`/forgot-password`) where users can submit their email address to initiate the password reset process by calling the password reset request API.",
        "details": "1. Create a new Next.js page route at `app/forgot-password/page.tsx`.\n2. Design and implement a form that includes:\n    - An input field for the user's email address.\n    - A submit button (e.g., 'Send Reset Link').\n3. Utilize reusable form components from Task 14 (e.g., `Input`, `Button`, `Form` from shadcn/ui) and client-side validation patterns using Zod and `react-hook-form`.\n    - Define a Zod schema for the email field (e.g., `z.object({ email: z.string().email({ message: 'Invalid email address' }) })`).\n4. On form submission:\n    - Prevent default form submission.\n    - Make a POST request to the `/api/auth/request-password-reset` endpoint (implemented in Task 20). The request body should be a JSON object containing the email: `{ \"email\": \"user@example.com\" }`.\n    - Use a library like `axios` or the native `fetch` API for the request.\n5. Handle API responses:\n    - On successful API response (e.g., HTTP 200), display a generic success message to the user, such as 'If an account with that email exists, a password reset link has been sent. Please check your inbox.' This is important for security to prevent email enumeration.\n    - On API error or network failure, display an appropriate error message to the user (e.g., 'An error occurred. Please try again.').\n    - Manage loading states for the form submission.\n6. Ensure the page is publicly accessible and does not require authentication.",
        "testStrategy": "1. Navigate to the `/forgot-password` page in a browser.\n2. **UI Verification**:\n    - Verify that the page renders correctly with an email input field and a submit button.\n3. **Client-Side Validation**:\n    - Attempt to submit the form with an empty email field. Verify that a client-side validation error message is displayed (e.g., 'Email is required').\n    - Enter an improperly formatted email (e.g., 'test@invalid') and attempt to submit. Verify that a client-side validation error message for invalid email format is displayed.\n4. **Successful Password Reset Request**:\n    - Enter the email address of a known, existing user and submit the form.\n    - **Expected**: A generic success message should be displayed (e.g., 'If an account with that email exists, a password reset link has been sent.').\n    - **Verification**: Check the browser's network developer tools to confirm that a POST request was made to `/api/auth/request-password-reset` with the correct email in the payload.\n5. **Password Reset Request for Non-Existing User**:\n    - Enter an email address that is known not to be registered in the system and submit the form.\n    - **Expected**: The same generic success message as in step 4 should be displayed to prevent email enumeration.\n    - **Verification**: Check the browser's network developer tools to confirm the API call was made.\n6. **API Error Handling (if mockable or testable)**:\n    - If the `/api/auth/request-password-reset` endpoint returns an error (e.g., 500 server error), verify that an appropriate error message is displayed on the page.\n7. **Accessibility**:\n    - Perform basic accessibility checks (e.g., keyboard navigation, proper labels for form fields).",
        "status": "done",
        "dependencies": [
          20,
          14
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Implement Password Reset API Endpoint",
        "description": "Implement an API endpoint to handle the actual password reset. This endpoint will receive the reset token and the new password, validate the token, hash the new password, and update the user's record in the database.",
        "details": "1.  **API Route Creation**: Create a new API route at `app/api/auth/reset-password/route.ts` to handle POST requests.\n2.  **Input Validation**: The endpoint should expect a JSON body containing `token` (string) and `newPassword` (string). Use Zod (from Task 5) to validate the `token` (e.g., non-empty string) and `newPassword` (e.g., minimum length 8 characters, any other complexity rules).\n3.  **Token Validation**: \n    *   Query the `PasswordResetToken` table (defined in Task 19) using Prisma (from Task 2) to find the provided `token`.\n    *   If the token is not found or if `new Date() > token.expires`, return a 400 Bad Request error (e.g., \"Invalid or expired password reset token\").\n4.  **User Lookup**: \n    *   If the token is valid, retrieve the `email` associated with the token.\n    *   Query the `User` table using Prisma to find the user by this `email`.\n    *   If no user is found for the email (which should be rare if the token is valid), return a 404 Not Found error or a generic error.\n5.  **Password Hashing**: \n    *   Hash the `newPassword` using `bcryptjs` (similar to Task 7). Generate a new salt and hash the password.\n6.  **Update User Record**: \n    *   Update the user's `password` field in the `User` table with the new hashed password.\n    *   Optionally, update the user's `updatedAt` timestamp.\n7.  **Token Invalidation**: \n    *   Delete the used `PasswordResetToken` from the database to prevent it from being used again.\n8.  **Response**: \n    *   On successful password reset, return a 200 OK response with a success message (e.g., `{ message: \"Password has been reset successfully.\" }`).\n    *   Return appropriate error responses (e.g., 400 for validation errors, invalid/expired token; 404 if user not found; 500 for unexpected server errors).",
        "testStrategy": "1.  **Successful Password Reset**:\n    *   Manually add a valid, non-expired `PasswordResetToken` to the database for an existing user.\n    *   Send a POST request to `/api/auth/reset-password` with the correct `token` and a valid `newPassword`.\n    *   **Expected**: HTTP 200 OK response.\n    *   **Verification**: Check the `User` table to confirm the password hash has changed. Attempt to log in with the new password. Verify the `PasswordResetToken` used has been deleted from the database.\n2.  **Invalid Token**:\n    *   Send a POST request with a `token` that does not exist in the `PasswordResetToken` table.\n    *   **Expected**: HTTP 400 Bad Request (or similar) error response.\n    *   **Verification**: User's password should remain unchanged.\n3.  **Expired Token**:\n    *   Manually add a `PasswordResetToken` to the database with an `expires` timestamp in the past.\n    *   Send a POST request with this expired `token`.\n    *   **Expected**: HTTP 400 Bad Request (or similar) error response indicating the token is expired.\n    *   **Verification**: User's password should remain unchanged.\n4.  **Invalid New Password (Validation Failure)**:\n    *   Send a POST request with a valid token but a `newPassword` that fails Zod validation (e.g., too short).\n    *   **Expected**: HTTP 400 Bad Request with a validation error message.\n    *   **Verification**: User's password should remain unchanged.\n5.  **Missing Token or New Password in Payload**:\n    *   Send a POST request missing the `token` or `newPassword` field in the JSON body.\n    *   **Expected**: HTTP 400 Bad Request with a validation error message.\n    *   **Verification**: User's password should remain unchanged.\n6.  **Attempt to Reuse Token**:\n    *   After a successful password reset, attempt to send another POST request using the same `token`.\n    *   **Expected**: HTTP 400 Bad Request (or similar) error, as the token should have been deleted.\n    *   **Verification**: User's password should not be affected by the second attempt.",
        "status": "done",
        "dependencies": [
          2,
          5,
          7,
          19
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Create 'Reset Password' Page",
        "description": "Develop the 'Reset Password' page (`/reset-password/[token]`) that allows users to set a new password after verifying a reset token received via email. The page will capture the token from URL parameters and include a form for the new password.",
        "details": "1.  **Page Route Creation**: Create a dynamic Next.js page route at `app/reset-password/[token]/page.tsx`.\n2.  **Token Extraction**: Implement logic to extract the `token` from the URL parameters. This can be done using `useParams` from `next/navigation` in a client component or the `params` prop if it's a server component rendering a client component that needs the token.\n3.  **Form Implementation**: \n    *   Design and implement a form containing two password input fields: 'New Password' and 'Confirm New Password', and a 'Reset Password' submit button.\n    *   Utilize reusable form components developed in Task 14 (e.g., `Input`, `Button`, `Form` from shadcn/ui).\n    *   Implement client-side validation using Zod (from Task 5) and `react-hook-form`. Define a Zod schema to ensure both password fields are non-empty, meet minimum length/complexity requirements, and that the 'Confirm New Password' field matches the 'New Password' field. Example schema:\n        ```typescript\n        import * as z from 'zod';\n\n        const passwordResetSchema = z.object({\n          newPassword: z.string().min(8, { message: 'Password must be at least 8 characters long' }),\n          confirmPassword: z.string().min(8, { message: 'Password must be at least 8 characters long' })\n        }).refine(data => data.newPassword === data.confirmPassword, {\n          message: \"Passwords don't match\",\n          path: [\"confirmPassword\"],\n        });\n        ```\n4.  **API Interaction**: On successful client-side validation and form submission, make a POST request to the 'Password Reset API Endpoint' (defined in Task 22). The request body should include the `token` (extracted from the URL) and the `newPassword`.\n5.  **User Feedback and Redirection**: \n    *   Upon a successful API response, display a success message to the user (e.g., \"Your password has been reset successfully. You can now log in with your new password.\").\n    *   Redirect the user to the login page (Task 16).\n    *   In case of API errors (e.g., invalid/expired token, server error), display appropriate and user-friendly error messages on the page.\n6.  **Component Structure**: It's recommended to create a dedicated client component (e.g., `ResetPasswordForm.tsx`) to encapsulate the form logic, state management (e.g., using `useState` or `react-hook-form`), validation, and API call handling. The page component (`app/reset-password/[token]/page.tsx`) would then import and render this form component.",
        "testStrategy": "1.  **UI Rendering and Token Handling**: \n    *   Navigate to a URL like `/reset-password/test-token`.\n    *   Verify that the page renders correctly, displaying input fields for 'New Password' and 'Confirm New Password', and a 'Reset Password' button.\n    *   Ensure the `test-token` is correctly captured by the page/form component.\n2.  **Client-Side Validation**: \n    *   Attempt to submit the form with empty password fields. Verify that appropriate client-side validation messages are displayed.\n    *   Enter a password shorter than the minimum requirement in the 'New Password' field. Verify the validation error.\n    *   Enter a valid 'New Password' but a different password in 'Confirm New Password'. Verify the mismatch error.\n3.  **Successful Password Reset Scenario**: \n    *   Prerequisite: Ensure the Password Reset API (Task 22) is functional. Manually generate or use a valid, non-expired password reset token for a test user.\n    *   Navigate to `/reset-password/[valid-token]` (replace `[valid-token]` with the actual token).\n    *   Enter a new, valid password in both fields and submit the form.\n    *   **Expected**: A success message is displayed, and the user is redirected to the login page.\n    *   **Verification**: Attempt to log in as the test user with the newly set password.\n4.  **Invalid or Expired Token Scenario**: \n    *   Navigate to `/reset-password/invalid-or-expired-token` (using a token known to be invalid or expired for testing with the API from Task 22).\n    *   Enter valid passwords in the form and submit.\n    *   **Expected**: An appropriate error message (e.g., \"Invalid or expired token. Please request a new password reset link.\") is displayed on the page, originating from the API response.\n5.  **API Error Handling (General)**: \n    *   If possible, simulate other API errors (e.g., server unavailable) when the form is submitted.\n    *   Verify that generic, user-friendly error messages are displayed on the page, preventing raw error exposure.",
        "status": "done",
        "dependencies": [
          14,
          5,
          22
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Mejorar la Interfaz y Estructura de la Página de Inicio",
        "description": "Rediseñar la página de inicio (`/`) para incluir un encabezado con acceso al login, un título principal, una sección de tarjetas informativas y un pie de página, creando una bienvenida moderna y funcional para el usuario.",
        "details": "La implementación se centrará en el archivo `app/page.tsx`. 1. **Crear Encabezado (Header)**: Implementar un componente de encabezado en la parte superior de la página. Debe mostrar el título 'Multiplataforma - DIAD' y un botón o enlace 'Login' que redirija a la página `/login`. Utilizar componentes de `shadcn/ui` para consistencia visual. 2. **Sección de Tarjetas (Cards)**: Debajo del contenido principal, crear una sección que contenga tres tarjetas dispuestas horizontalmente (en escritorio) y verticalmente (en móvil). Utilizar el componente `Card` de `shadcn/ui`. Los títulos de las tarjetas serán: 'Carga archivos', 'Ingresa tus datos' y 'Revisa la documentación'. Añadir un breve texto descriptivo a cada una. 3. **Pie de Página (Footer)**: Añadir un componente de pie de página simple en la parte inferior que contenga el texto 'DIAD - 2025'. 4. **Estilo y Responsividad**: Utilizar TailwindCSS para asegurar que el diseño sea moderno, limpio y completamente responsivo en dispositivos de escritorio y móviles.",
        "testStrategy": "1. **Verificación del Encabezado**: Navegar a la ruta raíz (`/`). Confirmar que el encabezado se muestra correctamente con el título 'Multiplataforma - DIAD'. Hacer clic en el botón 'Login' y verificar que redirige a la página `/login`. 2. **Verificación de las Tarjetas**: Desplazarse hacia abajo y confirmar la presencia de las tres tarjetas con sus respectivos títulos ('Carga archivos', 'Ingresa tus datos', 'Revisa la documentación'). 3. **Verificación del Pie de Página**: Asegurarse de que el pie de página es visible en la parte inferior de la página con el texto 'DIAD - 2025'. 4. **Pruebas de Responsividad**: Usar las herramientas de desarrollador del navegador para simular diferentes tamaños de pantalla (móvil, tableta, escritorio). Verificar que el layout se adapta correctamente, especialmente la disposición de las tarjetas y el menú de navegación.",
        "status": "done",
        "dependencies": [
          1,
          14
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Crear el Componente de Encabezado (Header)",
            "description": "Implementar un componente de encabezado reutilizable para la parte superior de la página. Este componente mostrará el título de la aplicación y un botón de inicio de sesión.",
            "dependencies": [],
            "details": "Crea un nuevo archivo, por ejemplo, en `components/layout/Header.tsx`. Dentro, define un componente que renderice una etiqueta `<header>`. Utiliza un `<h2>` para el título 'Multiplataforma - DIAD' y un componente `<Button>` de `shadcn/ui` con el texto 'Login'. Envuelve el botón en un componente `<Link>` de Next.js que apunte a `/login`. Usa Flexbox (`flex justify-between items-center`) para alinear los elementos. Finalmente, importa y renderiza este componente en la parte superior de `app/page.tsx`.",
            "status": "done",
            "testStrategy": "Verificar que el encabezado se renderiza correctamente, que el título es visible y que el botón 'Login' redirige a la ruta `/login` al hacer clic."
          },
          {
            "id": 2,
            "title": "Estructurar el Contenido Principal y Añadir Título de Bienvenida",
            "description": "Definir la estructura principal de la página de inicio, justo debajo del encabezado, e incluir un título principal H1 que sirva como bienvenida al usuario.",
            "dependencies": [],
            "details": "En `app/page.tsx`, debajo del componente `Header`, añade una etiqueta `<main>` que envuelva el resto del contenido de la página. Dentro de `<main>`, el primer elemento debe ser un `<h1>` con un texto como \"Bienvenido a la Plataforma de Análisis\". Utiliza clases de TailwindCSS para centrar el texto, aumentar su tamaño (`text-4xl`, `font-bold`) y añadir margen superior e inferior (`my-8`).",
            "status": "done",
            "testStrategy": "Comprobar que el título H1 aparece debajo del encabezado con el estilo y espaciado correctos."
          },
          {
            "id": 3,
            "title": "Implementar la Sección de Tarjetas Informativas",
            "description": "Desarrollar la sección que muestra tres tarjetas con información clave sobre las funcionalidades de la aplicación, utilizando los componentes de `shadcn/ui`.",
            "dependencies": [],
            "details": "Dentro de la etiqueta `<main>` en `app/page.tsx`, después del título H1, crea un `<div>` que funcionará como contenedor para las tarjetas. Dentro de este div, implementa tres componentes `<Card>` de `shadcn/ui`. Cada tarjeta debe contener un `<CardHeader>` con un `<CardTitle>` ('Carga archivos', 'Ingresa tus datos', 'Revisa la documentación') y un `<CardContent>` con un párrafo descriptivo breve para cada una.",
            "status": "done",
            "testStrategy": "Verificar que las tres tarjetas se renderizan con sus respectivos títulos y textos descriptivos."
          },
          {
            "id": 4,
            "title": "Aplicar Diseño Responsivo a la Página y las Tarjetas",
            "description": "Asegurar que toda la página, y en especial la sección de tarjetas, se visualice correctamente tanto en dispositivos móviles como en escritorios, ajustando su disposición de vertical a horizontal.",
            "dependencies": [],
            "details": "Modifica el `<div>` contenedor de las tarjetas. Aplica clases de TailwindCSS para establecer un layout de Grid: `grid grid-cols-1 md:grid-cols-3 gap-4`. Esto hará que las tarjetas se apilen verticalmente en pantallas pequeñas (`grid-cols-1`) y se muestren en tres columnas en pantallas medianas y grandes (`md:grid-cols-3`). El `gap-4` añadirá espacio entre ellas. Revisa el layout general de la página para asegurar que todos los elementos se ajustan correctamente.",
            "status": "done",
            "testStrategy": "Usar las herramientas de desarrollador del navegador para simular diferentes tamaños de pantalla (móvil, tablet, escritorio) y confirmar que el layout se adapta como se espera, especialmente la disposición de las tarjetas."
          },
          {
            "id": 5,
            "title": "Crear e Integrar el Pie de Página (Footer)",
            "description": "Implementar un componente de pie de página simple y añadirlo al final de la estructura de la página de inicio para completar el diseño.",
            "dependencies": [],
            "details": "Crea un nuevo componente, por ejemplo, en `components/layout/Footer.tsx`. Este componente debe renderizar una etiqueta `<footer>`. Dentro, añade un `<p>` con el texto 'DIAD - 2025'. Aplica clases de TailwindCSS para añadir padding (`py-4`), un borde superior (`border-t`) y centrar el texto (`text-center`). Importa y renderiza este componente al final del layout en `app/page.tsx`, después de la etiqueta `<main>`.",
            "status": "done",
            "testStrategy": "Verificar que el pie de página aparece en la parte inferior de la página con el texto y estilo correctos, y que permanece en la parte inferior independientemente del contenido."
          }
        ]
      },
      {
        "id": 25,
        "title": "Implementar Funcionalidades de Gestión de Usuarios en Panel de Administración",
        "description": "Crear una sección de administración para gestionar usuarios, incluyendo la importación masiva desde CSV, un listado con filtros y paginación, y la capacidad de modificar roles de usuario.",
        "details": "Esta tarea se divide en tres funcionalidades principales dentro de un nuevo panel de administración en la ruta `/admin/users`. 1. **Importación de Usuarios desde CSV**: Crear una página (`/admin/users/import`) con un formulario para subir archivos CSV. Implementar un endpoint de API (`/api/admin/users/import`) que utilice `papaparse` para procesar el archivo. Validar cada fila con Zod (email, nombre, rol) y usar `prisma.user.createMany()` para la inserción masiva, omitiendo duplicados. La API debe devolver un resumen de la operación (usuarios creados, errores). 2. **Listado de Usuarios**: En la página principal `/admin/users`, implementar una tabla (usando `shadcn/ui`) para mostrar los usuarios con paginación y filtros. Crear un endpoint de API (`/api/admin/users`) que acepte parámetros de consulta para filtrar por nombre/email/rol y para la paginación (usando `skip` y `take` de Prisma). 3. **Modificación de Rol**: En la tabla de usuarios, añadir un control (ej. un dropdown) para cambiar el rol de un usuario. Este control llamará a un endpoint de API (`PATCH /api/admin/users/[userId]`) que actualizará el rol del usuario en la base de datos. Es crucial actualizar el `middleware.ts` (de la Tarea 17) para proteger todas las rutas `/admin/*` y verificar que el usuario autenticado tenga el rol de 'ADMIN'.",
        "testStrategy": "1. **Seguridad de Rutas**: Intentar acceder a `/admin/users` sin iniciar sesión y verificar la redirección al login. Iniciar sesión como un usuario normal y verificar que el acceso es denegado. Iniciar sesión como administrador y verificar que el acceso es concedido. 2. **Importación CSV**: Subir un CSV válido y verificar que los nuevos usuarios aparecen en la base de datos y en el listado. Subir un CSV con datos inválidos (emails duplicados, formatos incorrectos) y verificar que se muestra un informe de errores preciso y que solo los datos válidos fueron procesados. 3. **Listado y Filtros**: Navegar a `/admin/users` y confirmar que la tabla se carga con la primera página de usuarios. Probar los controles de paginación. Usar los campos de filtro para buscar por email y rol, y verificar que la tabla se actualiza correctamente. 4. **Cambio de Rol**: En el listado, cambiar el rol de un usuario de 'USER' a 'ADMIN'. Verificar que el cambio se refleja en la base de datos. Iniciar sesión con la cuenta de ese usuario para confirmar que ahora tiene acceso a las rutas de administrador.",
        "status": "done",
        "dependencies": [
          17,
          7
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Proteger Rutas de Administración con Middleware",
            "description": "Actualizar el archivo `middleware.ts` para interceptar todas las peticiones a `/admin/*` y verificar que el usuario autenticado tenga el rol 'ADMIN'.",
            "dependencies": [],
            "details": "Modificar la función `middleware` en `middleware.ts`. Usar `next-auth` para obtener la sesión del usuario. Si la ruta coincide con `/admin/:path*` y el `session.user.role` no es 'ADMIN', redirigir a una página de no autorizado o a la página de inicio. Esta es una dependencia crítica para todas las demás tareas de administración.\n<info added on 2025-08-05T02:57:59.806Z>\nTarea completada exitosamente. Se corrigió el middleware.ts para proteger correctamente las rutas de administración:\n\n1. Se identificó que el middleware ya tenía la lógica de protección implementada:\n   - Detecta rutas /admin/* y /api/admin/* (línea 34)\n   - Verifica autenticación y rol de usuario (líneas 41-44)\n   - Redirige usuarios no autorizados a la página de inicio\n\n2. Se corrigió un problema crítico de mayúsculas/minúsculas:\n   - En el esquema de Prisma los roles son: 'user' y 'admin' (minúsculas).\n   - En el middleware se verificaba userRole !== \"ADMIN\" (mayúsculas).\n   - Se cambió a userRole !== \"admin\" para mantener la consistencia.\n\n3. Verificación funcional:\n   - El middleware ahora bloquea correctamente el acceso a las rutas de administración.\n   - Solo los usuarios con rol 'admin' pueden acceder a /admin/* y /api/admin/*.\n   - Los usuarios no autenticados son redirigidos a /login.\n   - Los usuarios autenticados sin rol de administrador son redirigidos a /.\n\nLa protección de rutas de administración está completamente funcional y lista para las siguientes subtareas del panel de administración.\n</info added on 2025-08-05T02:57:59.806Z>",
            "status": "done",
            "testStrategy": "Intentar acceder a `/admin/users` como usuario no autenticado (debería redirigir a login), como usuario sin rol 'ADMIN' (debería redirigir o mostrar error 403), y como usuario 'ADMIN' (debería permitir el acceso)."
          },
          {
            "id": 2,
            "title": "Crear Layout y Navegación del Panel de Administración",
            "description": "Establecer la estructura visual base para la sección de administración, incluyendo un layout persistente y enlaces de navegación.",
            "dependencies": [
              1
            ],
            "details": "Crear un nuevo componente de layout para las rutas `/admin/*`. Este layout debe incluir un encabezado o una barra lateral con enlaces de navegación, como 'Dashboard' y 'Gestión de Usuarios' (apuntando a `/admin/users`). Usar componentes de `shadcn/ui` para la estructura.\n<info added on 2025-08-05T03:40:43.411Z>\nArchivos creados/modificados:\n1. Creado `app/(protected)/admin/layout.tsx` - Layout persistente para todas las rutas admin con:\n   - Header con título \"Panel de Administración\", badge \"Admin\" y botón logout\n   - Sidebar de navegación con enlaces a Dashboard, Gestión de Usuarios y Configuración\n   - Diseño responsivo usando componentes shadcn/ui (Button, Badge)\n   - Íconos de Lucide React para mejor UX\n\n2. Actualizado `app/(protected)/admin/page.tsx` - Dashboard principal con:\n   - Cards de estadísticas para Total Usuarios, Verificados, Pendientes y Administradores\n   - Diseño moderno con grid responsivo\n   - Placeholders preparados para futuras APIs\n   - Componentes Card de shadcn/ui\n\nDependencias instaladas:\n- `npx shadcn add card` - Para las tarjetas de estadísticas\n- `npx shadcn add badge` - Para el indicador de rol admin\n\nEstructura implementada:\n- Header fijo con información de usuario y logout\n- Sidebar de navegación con 3 enlaces principales\n- Área de contenido principal responsive\n- Diseño profesional con Tailwind CSS y shadcn/ui\n\nVerificaciones:\n- ✅ Lint: Sin errores\n- ✅ Componentes funcionan correctamente\n- ✅ Layout se aplica a todas las rutas `/admin/*`\n- ✅ Navegación lista para futuras páginas\n</info added on 2025-08-05T03:40:43.411Z>\n<info added on 2025-08-05T04:06:27.181Z>\nProblema de middleware resuelto exitosamente.\n\nProblema identificado: El middleware estaba usando `NextAuth(authConfig)` que no incluía los callbacks necesarios para el campo `role` en la sesión.\n\nSolución implementada:\n1. Se cambió el middleware para usar `import { auth } from \"@/auth\"` en lugar de `NextAuth(authConfig)`.\n2. Esto asegura que el middleware use la configuración completa de NextAuth con todos los callbacks.\n\nResultado: El panel de administración ahora es accesible para usuarios con rol `admin`. La protección de rutas funciona correctamente:\n- Usuarios no autenticados son redirigidos a `/login`.\n- Usuarios sin rol admin son redirigidos a `/`.\n- Usuarios con rol admin tienen acceso permitido a `/admin/*`.\n\nEl layout y navegación del panel admin están completamente funcionales.\n</info added on 2025-08-05T04:06:27.181Z>",
            "status": "done",
            "testStrategy": "Navegar a `/admin/users` y verificar que el layout de administración se renderiza correctamente con los enlaces de navegación visibles y funcionales."
          },
          {
            "id": 3,
            "title": "Crear API para Listado Paginado de Usuarios",
            "description": "Implementar el endpoint `GET /api/admin/users` que devuelve una lista de usuarios con soporte para paginación.",
            "dependencies": [
              1
            ],
            "details": "Crear un nuevo `route.ts` en `app/api/admin/users`. La función `GET` debe aceptar los parámetros de consulta `page` y `limit`. Calcular `skip` (`(page - 1) * limit`) y `take` (`limit`). Usar `prisma.user.findMany({ skip, take })` y `prisma.user.count()` para obtener los datos y el total de usuarios. Devolver los usuarios y la información de paginación (total de páginas, total de usuarios).\n<info added on 2025-08-12T16:40:59.486Z>\nImplementación completada exitosamente. El endpoint GET /api/admin/users se ha implementado con las siguientes características:\n- Autenticación y autorización para verificar que el usuario esté autenticado y tenga el rol 'admin'.\n- Acepta parámetros de consulta 'page' (por defecto 1) y 'limit' (por defecto 10, máximo 100), con validación para asegurar que los valores estén en un rango válido.\n- Utiliza Promise.all para ejecutar en paralelo la consulta de usuarios y el conteo total, mejorando la eficiencia.\n- Los usuarios se devuelven ordenados por fecha de creación descendente (más recientes primero).\n- La respuesta incluye una metadata de paginación completa: currentPage, totalPages, totalUsers, limit, hasNextPage, y hasPreviousPage.\nSe realizaron pruebas exitosas de lint, lógica de paginación, estructura de respuesta, middleware de autenticación, validación de parámetros y casos de borde. El endpoint está listo para ser consumido por el frontend.\n</info added on 2025-08-12T16:40:59.486Z>",
            "status": "done",
            "testStrategy": "Realizar peticiones a `/api/admin/users?page=1&limit=10` y `/api/admin/users?page=2&limit=10` y verificar que se devuelven los conjuntos de datos correctos y la metadata de paginación."
          },
          {
            "id": 4,
            "title": "Implementar Tabla de Usuarios en el Frontend",
            "description": "Desarrollar la interfaz de usuario en `/admin/users` para mostrar la lista de usuarios en una tabla.",
            "dependencies": [
              2,
              3
            ],
            "details": "Crear la página `/admin/users/page.tsx`. Utilizar los componentes `Table`, `TableHeader`, `TableBody`, etc., de `shadcn/ui`. Realizar una llamada al endpoint `/api/admin/users` para obtener los datos y renderizarlos en la tabla. Las columnas deben incluir como mínimo: Nombre, Email y Rol.",
            "status": "done",
            "testStrategy": "Verificar que la página `/admin/users` carga y muestra correctamente la primera página de usuarios obtenida de la API en la tabla."
          },
          {
            "id": 5,
            "title": "Añadir Controles de Paginación a la Tabla de Usuarios",
            "description": "Integrar componentes de paginación en la interfaz de la tabla de usuarios para permitir la navegación entre páginas.",
            "dependencies": [
              4
            ],
            "details": "En la página `/admin/users`, añadir los componentes `Pagination` de `shadcn/ui` debajo de la tabla. Conectar los botones 'Siguiente', 'Anterior' y los números de página para que actualicen el estado de la página actual, realicen una nueva llamada a la API con el parámetro `page` correspondiente y refresquen los datos de la tabla.",
            "status": "done",
            "testStrategy": "Hacer clic en los botones de paginación y verificar que la tabla se actualiza con los usuarios de la página correspondiente."
          },
          {
            "id": 6,
            "title": "Extender API de Usuarios con Lógica de Filtrado",
            "description": "Mejorar el endpoint `GET /api/admin/users` para que admita filtrado por nombre, email y rol.",
            "dependencies": [
              3
            ],
            "details": "Modificar la función `GET` en `app/api/admin/users/route.ts`. Leer los parámetros de consulta opcionales `search` (para nombre/email) y `role`. Construir dinámicamente la cláusula `where` de Prisma para incluir condiciones `contains` para el `search` y `equals` para el `role` si los parámetros están presentes.",
            "status": "done",
            "testStrategy": "Realizar peticiones como `/api/admin/users?search=john` y `/api/admin/users?role=USER` y verificar que la API devuelve solo los usuarios que coinciden con los filtros."
          },
          {
            "id": 7,
            "title": "Implementar Controles de Filtro en la Interfaz de Usuarios",
            "description": "Añadir campos de entrada en la página de listado de usuarios para permitir al administrador filtrar los resultados.",
            "dependencies": [
              5,
              6
            ],
            "details": "En la página `/admin/users`, añadir un componente `Input` de `shadcn/ui` para la búsqueda por texto (nombre/email) y un `Select` o `DropdownMenu` para filtrar por rol. Al cambiar el valor de estos controles, se debe realizar una nueva petición a la API con los parámetros `search` y/o `role` y actualizar la tabla.",
            "status": "done",
            "testStrategy": "Escribir en el campo de búsqueda y seleccionar un rol en el dropdown. Verificar que la lista de usuarios en la tabla se actualiza para reflejar los filtros aplicados."
          },
          {
            "id": 8,
            "title": "Crear API para Modificar Rol de Usuario",
            "description": "Implementar el endpoint `PATCH /api/admin/users/[userId]` para actualizar el rol de un usuario específico.",
            "dependencies": [
              1
            ],
            "details": "Crear un `route.ts` en `app/api/admin/users/[userId]`. La función `PATCH` debe leer el `userId` de los parámetros de la ruta y el nuevo `role` del cuerpo de la petición. Validar el rol entrante. Usar `prisma.user.update({ where: { id: userId }, data: { role } })` para actualizar el registro en la base de datos. Devolver el usuario actualizado.\n<info added on 2025-08-12T17:10:02.287Z>\nImplementation completed successfully. The PATCH endpoint at /api/admin/users/[userId] was created to modify user roles. A new Zod schema, `updateUserRoleSchema`, was added to `lib/zod.ts` for validating the role (`user` or `admin`). The implementation includes authentication and authorization to ensure only admins can perform the update. A security measure was added to prevent an admin from removing their own admin role. The endpoint handles multiple error cases, including 401 (unauthorized), 400 (invalid input), 403 (self-demotion attempt), 404 (user not found), and 500 (server error). Successful requests return a structured JSON response with the updated user. The endpoint is fully tested and functional.\n</info added on 2025-08-12T17:10:02.287Z>",
            "status": "done",
            "testStrategy": "Enviar una petición PATCH a `/api/admin/users/some-id` con `{\"role\": \"ADMIN\"}` en el cuerpo y verificar que la base de datos se actualiza y la API devuelve el usuario con el nuevo rol."
          },
          {
            "id": 9,
            "title": "Añadir Control para Cambiar Rol en la Tabla",
            "description": "Integrar un control en cada fila de la tabla de usuarios para permitir la modificación directa del rol.",
            "dependencies": [
              7,
              8
            ],
            "details": "En el componente de la tabla de usuarios, añadir una nueva columna 'Acciones'. Dentro de esta columna, para cada fila, renderizar un componente `Select` o `DropdownMenu` de `shadcn/ui` con los roles disponibles. Al seleccionar un nuevo rol, se debe llamar al endpoint `PATCH /api/admin/users/[userId]` con el ID del usuario y el nuevo rol. Actualizar la UI tras una respuesta exitosa.",
            "status": "done",
            "testStrategy": "En la lista de usuarios, cambiar el rol de un usuario usando el nuevo control. Refrescar la página y verificar que el cambio de rol persiste."
          },
          {
            "id": 10,
            "title": "Crear API para Importación Masiva de Usuarios desde CSV",
            "description": "Implementar el endpoint `POST /api/admin/users/import` que procesa un archivo CSV subido.",
            "dependencies": [
              1
            ],
            "details": "Crear un `route.ts` en `app/api/admin/users/import`. La función `POST` debe manejar una petición `multipart/form-data`. Usar una librería como `papaparse` para parsear el contenido del archivo CSV a un array de objetos JSON. La API debe estar preparada para el siguiente paso de validación e inserción.",
            "status": "done",
            "testStrategy": "Enviar un archivo CSV a través de una herramienta como Postman al endpoint y verificar que la API puede leer y parsear el contenido correctamente sin errores."
          },
          {
            "id": 11,
            "title": "Implementar Validación y Lógica de Inserción para Importación CSV",
            "description": "Añadir validación de datos con Zod y la inserción en base de datos al endpoint de importación.",
            "dependencies": [
              10
            ],
            "details": "Dentro del endpoint `POST /api/admin/users/import`, después de parsear el CSV, iterar sobre cada fila. Usar un esquema de Zod para validar que cada registro tenga `email` (formato válido), `name` (string no vacío) y `role` (enum válido). Usar `prisma.user.createMany({ data: validUsers, skipDuplicates: true })` para insertar los usuarios válidos. Devolver un resumen JSON: `{ created: X, skipped: Y, errors: [...] }`.",
            "status": "done",
            "testStrategy": "Subir un CSV con datos válidos, duplicados y erróneos. Verificar que la respuesta de la API refleja correctamente el número de usuarios creados, omitidos y los errores de validación específicos."
          },
          {
            "id": 12,
            "title": "Crear Página de Frontend para Subir Archivo CSV",
            "description": "Desarrollar la interfaz en `/admin/users/import` que permita a los administradores subir un archivo CSV.",
            "dependencies": [
              2,
              11
            ],
            "details": "Crear la página `/admin/users/import/page.tsx`. Usar componentes de `shadcn/ui` para crear un formulario con un campo de subida de archivo (`Input type='file'`) y un botón de envío. Al enviar el formulario, realizar una petición `POST` al endpoint `/api/admin/users/import` con el archivo. Mostrar un mensaje de estado (cargando, éxito, error) y presentar el resumen de la operación devuelto por la API.",
            "status": "done",
            "testStrategy": "Navegar a `/admin/users/import`, seleccionar un archivo CSV y subirlo. Verificar que se muestra un feedback visual durante la subida y que el resumen de la operación (creados, errores) se muestra al usuario después."
          }
        ]
      },
      {
        "id": 26,
        "title": "Implement Statistics Section in Admin Dashboard",
        "description": "Develop the main admin dashboard page to display key user statistics via summary cards and a registration trend chart. This will provide administrators with a quick overview of platform activity.",
        "details": "This task involves creating a new API endpoint to aggregate user statistics and a new frontend page within the admin panel to display them. 1. **Backend API Endpoint**: Create a new protected API route at `/api/admin/stats`. This route should only be accessible to users with the 'ADMIN' role. The endpoint will query the database using Prisma to calculate the following metrics: Total Users (`prisma.user.count()`), New Users Today (`prisma.user.count({ where: { createdAt: ... } })`), Total Admins (`prisma.user.count({ where: { role: 'ADMIN' } })`), and Active Users (e.g., distinct users with a session in the last 30 days). For the 7-day registration trend, the endpoint must return an array of objects, each containing a date and the count of users registered on that date for the past week. 2. **Frontend Implementation**: Create a new page at `/admin/dashboard`. This page will fetch data from the `/api/admin/stats` endpoint. Use a data fetching library like SWR or React Query for client-side fetching, including loading and error states. 3. **UI Components**: Develop a reusable `StatCard` component to display each key metric. For the registration trend, install and use a charting library like 'recharts' (`npm install recharts`) to create a line or bar chart visualizing the 7-day data.",
        "testStrategy": "1. **API Security**: Attempt to access `/api/admin/stats` as a logged-out user and as a logged-in non-admin user. Both attempts should result in a 401 Unauthorized or 403 Forbidden error. Accessing the endpoint as an admin should return a 200 OK response with the statistics payload. 2. **API Data Accuracy**: Manually add/modify users in the database with various roles and `createdAt` timestamps. Call the API and verify that all returned metrics (total users, new users today, total admins) and the 7-day trend data are accurate. 3. **Frontend Verification**: Log in as an admin and navigate to the `/admin/dashboard` page. Verify that all statistic cards and the registration chart render correctly with the data from the API. Confirm that a loading state is visible during the initial data fetch and that an error message is displayed if the API call fails.",
        "status": "done",
        "dependencies": [
          7,
          8,
          17,
          25
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create and Secure the Admin Statistics API Endpoint",
            "description": "Set up the basic file structure for the `/api/admin/stats` API route and implement role-based access control to ensure only users with the 'ADMIN' role can access it. This foundational step prevents unauthorized data access before implementing the data logic.",
            "dependencies": [],
            "details": "Create a new route handler at `app/api/admin/stats/route.ts`. Inside the `GET` handler, use `getServerSession` from `next-auth` to retrieve the user's session. Check if `session.user.role` is equal to 'ADMIN'. If the user is not an admin or is not logged in, return a `NextResponse` with a 403 Forbidden status. If they are an admin, return a placeholder JSON object with a 200 OK status for now, e.g., `{ \"message\": \"Access granted\" }`.",
            "status": "done",
            "testStrategy": "1. Attempt to access `/api/admin/stats` via a tool like Postman or curl as a logged-out user (expect 401/403). 2. Log in as a regular user and attempt access (expect 403). 3. Log in as an admin and attempt access (expect 200 OK with the placeholder message)."
          },
          {
            "id": 2,
            "title": "Implement Summary Statistics Calculation in API",
            "description": "Extend the `/api/admin/stats` endpoint to calculate and return the primary summary statistics: Total Users, New Users Today, and Total Admins. This provides the data needed for the top-level summary cards.",
            "dependencies": [
              "26.1"
            ],
            "details": "In `app/api/admin/stats/route.ts`, use Prisma to perform the database queries. Calculate the start of the current day. Use `Promise.all` to execute the following queries concurrently: `prisma.user.count()`, `prisma.user.count({ where: { role: 'ADMIN' } })`, and `prisma.user.count({ where: { createdAt: { gte: startOfDay } } })`. Structure the response to return these values in a clear JSON object, e.g., `{ \"summary\": { \"totalUsers\": 150, \"newUsersToday\": 5, \"totalAdmins\": 3 } }`.",
            "status": "done",
            "testStrategy": "Call the endpoint as an admin. Verify the returned counts for total users, new users, and admins match the current state of the database. Manually add a new user via your application or database client and re-run the request to confirm the 'newUsersToday' count increments."
          },
          {
            "id": 3,
            "title": "Implement 7-Day Registration Trend Calculation in API",
            "description": "Enhance the `/api/admin/stats` endpoint to calculate and include the user registration trend for the last 7 days. This data will be used to power the registration chart.",
            "dependencies": [
              "26.2"
            ],
            "details": "In the same API route, implement logic to get user registration counts for each of the last 7 days. You can achieve this with a Prisma `groupBy` query on the `createdAt` field, filtering for records within the last 7 days. Process the results to create an array of 7 objects, one for each day, ensuring that days with zero registrations are included. The final structure should be like `[{ date: 'YYYY-MM-DD', count: 12 }, ...]`. Add this array to the API response payload under a key like `registrationTrend`.",
            "status": "done",
            "testStrategy": "Call the endpoint as an admin and inspect the `registrationTrend` array. Verify it contains exactly 7 entries, one for each of the past 7 days. Check that the counts for a few days are accurate based on the database records. Ensure a day with no new users shows a count of 0."
          },
          {
            "id": 4,
            "title": "Set Up Admin Dashboard Page with Data Fetching",
            "description": "Create the new frontend page at `/admin/dashboard` and implement client-side data fetching from the `/api/admin/stats` endpoint using SWR. This includes handling loading and error states.",
            "dependencies": [
              "26.3"
            ],
            "details": "Create the page file at `app/admin/dashboard/page.tsx`. Mark it as a client component with `'use client'`. Use the `useSWR` hook to fetch data from `/api/admin/stats`. Define a simple fetcher function for SWR. Based on the hook's return values (`data`, `error`, `isLoading`), render a loading indicator (e.g., a spinner), an error message, or the main dashboard content. Initially, you can render the fetched data using `<pre>{JSON.stringify(data, null, 2)}</pre>` to confirm it's working.",
            "status": "done",
            "testStrategy": "Navigate to `/admin/dashboard` as an admin. Verify the loading state appears briefly, followed by the raw JSON data from the API. Test the error state by temporarily renaming the API route file and reloading the page; an error message should be displayed."
          },
          {
            "id": 5,
            "title": "Create Reusable StatCard UI Component",
            "description": "Develop a reusable React component named `StatCard` to display a single statistic with a title and a value. This component will be used to display each of the summary metrics.",
            "dependencies": [],
            "details": "Create a new component file at `components/admin/StatCard.tsx`. The component should accept props for `title` (string) and `value` (string or number). Use Tailwind CSS to style it as a card with a background, padding, and distinct typography for the title and the value. The title should be smaller and less prominent than the large, bold value.",
            "status": "done",
            "testStrategy": "Use a tool like Storybook or a temporary test page to render the `StatCard` component with various static props (e.g., title='Total Users', value=1234) to ensure it displays correctly and is visually appealing."
          },
          {
            "id": 6,
            "title": "Integrate StatCards into Dashboard Page",
            "description": "Use the fetched statistics data to render multiple `StatCard` components on the `/admin/dashboard` page, creating the main summary section.",
            "dependencies": [
              "26.4",
              "26.5"
            ],
            "details": "On the `/admin/dashboard` page, once the SWR fetch is successful and `data` is available, render a grid (e.g., using CSS Grid or Flexbox). Inside the grid, render three instances of the `StatCard` component. Pass the relevant data from the API response to each card, for example: `<StatCard title=\"Total Users\" value={data.summary.totalUsers} />`, `<StatCard title=\"New Users Today\" value={data.summary.newUsersToday} />`, etc.",
            "status": "done",
            "testStrategy": "Load the dashboard page as an admin. Verify that three stat cards appear at the top of the page, displaying the correct titles and values fetched from the API. Check that the layout is responsive on different screen sizes."
          },
          {
            "id": 7,
            "title": "Create Registration Trend Chart Component",
            "description": "Install 'recharts' and create a new, dedicated component that uses it to render a line chart for displaying user registration trends over time.",
            "dependencies": [],
            "details": "First, run `npm install recharts`. Create a new component file at `components/admin/RegistrationChart.tsx`. This component should accept the `registrationTrend` data array as a prop. Inside the component, use `recharts` components like `ResponsiveContainer`, `LineChart`, `Line`, `XAxis`, `YAxis`, `CartesianGrid`, and `Tooltip` to build the chart. The `XAxis` should use the `date` key from the data, and the `Line` should use the `count` key.",
            "status": "done",
            "testStrategy": "Render the `RegistrationChart` component in Storybook or a temporary page, passing it a mock array of 7-day data. Verify that the chart renders correctly with axes, a data line, and a functional tooltip that shows the count on hover."
          },
          {
            "id": 8,
            "title": "Integrate Registration Chart into Dashboard Page",
            "description": "Add the `RegistrationChart` component to the `/admin/dashboard` page and pass the 7-day registration trend data from the API fetch to it, completing the dashboard's UI.",
            "dependencies": [
              "26.4",
              "26.7"
            ],
            "details": "On the `/admin/dashboard` page, below the grid of `StatCard`s, render the `RegistrationChart` component. Pass the `data.registrationTrend` array from the SWR fetch to the chart component's data prop. Wrap the chart in a container with a title, such as 'New Registrations (Last 7 Days)'.",
            "status": "done",
            "testStrategy": "Load the dashboard page as an admin. Verify that the line chart renders below the stat cards and accurately visualizes the registration data from the API. Hover over points on the chart to ensure the tooltip displays the correct date and user count."
          }
        ]
      },
      {
        "id": 27,
        "title": "Implement Quick Actions Section in Admin Dashboard",
        "description": "Create a 'Quick Actions' component for the main admin dashboard, providing administrators with one-click access to common tasks like exporting user data, copying an invitation link, viewing recent activity, and navigating to system settings.",
        "details": "This task involves creating a new UI component on the main admin dashboard page. 1. **Component Creation**: Develop a new React component, `QuickActions.tsx`, to be placed on the dashboard page created in Task #26. The component should display four distinct actions, likely as cards or large buttons with icons. 2. **Export User Data**: Implement a new protected API endpoint at `/api/admin/users/export`. This endpoint will use Prisma to fetch all user records (selecting fields like id, name, email, role, createdAt) and convert the data to a CSV formatted string using a library like `papaparse`. The response headers must be set to `Content-Type: text/csv` and `Content-Disposition: attachment; filename=\"users-export.csv\"` to trigger a download. The frontend button will link directly to this endpoint. 3. **Copy Invitation Link**: This is a client-side feature. The button will use the `navigator.clipboard.api` to copy a static registration link (e.g., `/register?ref=admin`) to the clipboard and display a toast notification for user feedback. 4. **View Recent Activity & Configure System**: These two actions will be simple navigation links. They should point to `/admin/activity-log` and `/admin/settings` respectively. The creation of these pages is out of scope for this task.",
        "testStrategy": "1. **UI and Security Verification**: Log in as an administrator and navigate to the main dashboard. Confirm the 'Quick Actions' section is visible and correctly rendered. Log in as a regular user and verify that the admin dashboard is inaccessible. 2. **Export Functionality**: As an admin, click the 'Export User Data' button. Verify a CSV file is downloaded. Open the file and check that its contents accurately reflect the user data in the database. Attempt to access the `/api/admin/users/export` URL directly while logged out or as a regular user and confirm access is denied with a 403 Forbidden error. 3. **Copy Link Functionality**: Click the 'Copy Invitation Link' button. Verify a success message appears. Paste the clipboard contents into a text field to ensure the correct URL has been copied. 4. **Navigation Links**: Click the 'View Recent Activity' and 'Configure System' links and verify that the browser attempts to navigate to `/admin/activity-log` and `/admin/settings` respectively.",
        "status": "done",
        "dependencies": [
          17,
          25,
          26
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `QuickActions.tsx` Component Shell and Integrate into Dashboard",
            "description": "Create the basic structure for the `QuickActions` component. This includes creating the file, setting up a container (e.g., a grid), and adding placeholder elements for the four actions. This component should then be imported and rendered on the main admin dashboard page from Task #26.",
            "dependencies": [],
            "details": "Create a new file at `components/admin/QuickActions.tsx`. Use a `div` with CSS Grid or Flexbox to lay out four placeholder child elements. Each placeholder can be a simple `div` with a title like 'Export Users'. Import this new component into the main dashboard page component (e.g., `app/admin/dashboard/page.tsx`) and render it in the appropriate location.",
            "status": "done",
            "testStrategy": "Navigate to the admin dashboard page. Verify that the 'Quick Actions' section is visible with four placeholder items."
          },
          {
            "id": 2,
            "title": "Implement Protected API Endpoint for User Data Export",
            "description": "Create a new protected API route at `/api/admin/users/export` that fetches all user data using Prisma, converts it to a CSV string, and returns it as a downloadable file.",
            "dependencies": [],
            "details": "Create a new route handler at `app/api/admin/users/export/route.ts`. Protect this route to ensure only authenticated admins can access it (e.g., by checking the user's session and role). Use Prisma to fetch users, selecting only necessary fields (`id`, `name`, `email`, `role`, `createdAt`). Use a library like `papaparse` to convert the JSON array to a CSV string. Set the response headers: `Content-Type: text/csv` and `Content-Disposition: attachment; filename=\"users-export.csv\"`.",
            "status": "done",
            "testStrategy": "While logged in as an admin, directly access `/api/admin/users/export` in the browser. Verify that a file named `users-export.csv` is downloaded. Open the file and confirm it contains the correct user data. Attempt to access the endpoint as a non-admin or unauthenticated user and verify access is denied."
          },
          {
            "id": 3,
            "title": "Implement 'Export User Data' Action on the Frontend",
            "description": "Replace the 'Export User Data' placeholder in the `QuickActions` component with a functional link or button that directs the user to the export API endpoint, triggering a file download.",
            "dependencies": [
              "27.1",
              "27.2"
            ],
            "details": "In `QuickActions.tsx`, replace the placeholder for the export action with an `<a>` tag. Set the `href` attribute to `'/api/admin/users/export'`. Style this link to look like a button or action card. Add an appropriate icon (e.g., a download icon).",
            "status": "done",
            "testStrategy": "As an admin, navigate to the dashboard and click the 'Export User Data' button. Verify that the CSV file download is initiated."
          },
          {
            "id": 4,
            "title": "Implement 'Copy Invitation Link' Client-Side Action",
            "description": "Implement the functionality for the 'Copy Invitation Link' button. This action will be purely client-side, using the browser's Clipboard API to copy a predefined link and showing a toast notification on success.",
            "dependencies": [
              "27.1"
            ],
            "details": "In `QuickActions.tsx`, replace the placeholder for this action with a `<button>`. Create an `onClick` handler function. Inside the handler, use `navigator.clipboard.writeText('/register?ref=admin')`. After the promise resolves, trigger a toast notification (using a library like `react-hot-toast` or similar) to inform the user 'Invitation link copied!'. Add a copy icon to the button.",
            "status": "done",
            "testStrategy": "Click the 'Copy Invitation Link' button. Verify that a success notification appears. Paste the content into a text editor to confirm the correct link (`/register?ref=admin`) was copied."
          },
          {
            "id": 5,
            "title": "Implement Navigation Links for 'View Recent Activity' and 'System Settings'",
            "description": "Replace the remaining two placeholders with navigation links that direct the administrator to the 'Recent Activity' and 'System Settings' pages.",
            "dependencies": [
              "27.1"
            ],
            "details": "In `QuickActions.tsx`, use the Next.js `<Link>` component for these two actions. The 'View Recent Activity' link should have an `href` of `'/admin/activity-log'`. The 'Configure System' link should have an `href` of `'/admin/settings'`. Add appropriate icons for each link (e.g., a list/log icon and a gear/settings icon).",
            "status": "done",
            "testStrategy": "Click the 'View Recent Activity' link and verify the URL changes to `/admin/activity-log`. Go back and click the 'Configure System' link and verify the URL changes to `/admin/settings`."
          },
          {
            "id": 6,
            "title": "Apply Final Styling and Icons to the Quick Actions Component",
            "description": "Apply consistent styling to all four action items to make them visually appealing and cohesive with the dashboard's design. Ensure each action has a clear title and a relevant icon.",
            "dependencies": [
              "27.3",
              "27.4",
              "27.5"
            ],
            "details": "Use a CSS framework like Tailwind CSS or a component library to style the action items as cards or large buttons. Ensure they have hover and focus states for better UX. Use a consistent icon set (e.g., from `lucide-react` or `heroicons`). The final component should be responsive and look good on different screen sizes.",
            "status": "done",
            "testStrategy": "Visually inspect the Quick Actions section on the dashboard. Confirm all four actions are styled consistently, have icons, are aligned correctly, and respond well to different viewport sizes. Check hover and active states for each action."
          }
        ]
      },
      {
        "id": 28,
        "title": "Implement Role-Based Post-Login Redirection",
        "description": "Update the authentication logic to redirect users to different pages based on their role after a successful login. Administrators will be sent to the admin dashboard, while regular users will be directed to their personal dashboard.",
        "details": "The primary goal is to create a centralized redirection logic that executes immediately after a user authenticates. This will be achieved by creating a dedicated post-login handler page. 1. **Ensure Role in Session**: Verify that the `[...nextauth]` configuration file correctly includes the user's `role` in the session token. The `jwt` callback should add the role from the user object to the token, and the `session` callback should expose the role from the token to the client-side session object. 2. **Create Post-Login Handler Page**: Create a new client component at `app/auth/post-login/page.tsx`. This page will act as a router. 3. **Implement Redirection Logic**: Inside the `post-login` component, use the `useSession` hook from `next-auth/react` and the `useRouter` hook from `next/navigation`. Use a `useEffect` hook to check the session status. If the status is 'loading', display a loading indicator. Once the status is 'authenticated', inspect the `session.user.role` property. If the role is 'ADMIN', use `router.replace('/admin')`. For any other role (e.g., 'USER'), use `router.replace('/dashboard')`. If the user is unauthenticated, redirect them back to `/login`. 4. **Update Login Flow**: Modify all `signIn()` function calls (e.g., in the login form) to specify the new handler page as the destination, for example: `signIn('credentials', { ...data, callbackUrl: '/auth/post-login' })`.",
        "testStrategy": "1. **Admin Login Test**: Log out completely. Navigate to the login page and sign in using an account with the 'ADMIN' role. Verify that you are automatically and correctly redirected to the admin dashboard (`/admin`). 2. **Regular User Login Test**: Log out completely. Navigate to the login page and sign in using a standard user account. Verify that you are automatically redirected to the main user dashboard (`/dashboard`). 3. **Manual Navigation Check**: After being logged in as a regular user, attempt to manually navigate to `/admin`. Verify that access is denied (as per existing middleware rules). 4. **Callback URL Check**: Inspect the network request during login to ensure the `callbackUrl` is being set to `/auth/post-login` correctly.",
        "status": "pending",
        "dependencies": [
          18,
          26
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Update NextAuth.js Configuration to Include User Role in Session",
            "description": "Modify the NextAuth.js configuration to ensure the user's role is available in the client-side session object. This involves updating the `jwt` and `session` callbacks to pass the role from the user database model to the session token and then to the client.",
            "dependencies": [],
            "details": "1. Open the NextAuth.js configuration file (e.g., `app/api/auth/[...nextauth]/route.ts`).\n2. In the `callbacks` object, locate the `jwt` callback. Inside, ensure the `user.role` is added to the `token` object when the user first signs in.\n3. Locate the `session` callback. Inside, retrieve the `role` from the `token` object and assign it to `session.user.role`.\n4. Update the TypeScript types in `next-auth.d.ts` to include `role: string;` in the `User` and `Session` interfaces to ensure type safety.",
            "status": "pending",
            "testStrategy": "After logging in, use browser developer tools to inspect the session object returned by the `useSession` hook in any client component. Verify that `session.user.role` exists and contains the correct value ('ADMIN' or 'USER')."
          },
          {
            "id": 2,
            "title": "Create the Post-Login Redirection Handler Page",
            "description": "Create a new client-side page component that will act as a central router after a user successfully logs in. This page will contain the redirection logic and display a loading state while processing.",
            "dependencies": [],
            "details": "1. Create a new file at `app/auth/post-login/page.tsx`.\n2. Define a React component (e.g., `PostLoginPage`) within this file.\n3. Add the `\"use client\";` directive at the top of the file.\n4. The component should render a simple loading indicator, such as a spinner or a 'Redirecting...' message, to provide user feedback.",
            "status": "pending",
            "testStrategy": "Manually navigate to `/auth/post-login` in the browser. Verify that the loading state UI is displayed correctly without any errors."
          },
          {
            "id": 3,
            "title": "Implement Role-Based Redirection Logic in Handler Page",
            "description": "Add the core logic to the post-login handler page to inspect the user's session and role, then redirect them to the appropriate dashboard or back to the login page if unauthenticated.",
            "dependencies": [
              "28.1",
              "28.2"
            ],
            "details": "1. In `app/auth/post-login/page.tsx`, import and use the `useSession` hook from `next-auth/react` and the `useRouter` hook from `next/navigation`.\n2. Implement a `useEffect` hook that triggers when the session `status` changes.\n3. Inside the `useEffect`:\n   - If `status === 'authenticated'`, check `session.user.role`.\n   - If the role is 'ADMIN', call `router.replace('/admin')`.\n   - For any other role (e.g., 'USER'), call `router.replace('/dashboard')`.\n   - If `status === 'unauthenticated'`, call `router.replace('/login')` to handle cases where a user lands here without a session.",
            "status": "pending",
            "testStrategy": "After logging in as an admin, manually navigate to `/auth/post-login`. Verify you are redirected to `/admin`. Log out, log in as a regular user, and manually navigate to `/auth/post-login`. Verify you are redirected to `/dashboard`."
          },
          {
            "id": 4,
            "title": "Update Login Form to Use the Post-Login Handler",
            "description": "Modify the `signIn` function calls in the application's login form to use the new post-login handler page as the `callbackUrl`, ensuring all successful logins are routed through the new redirection logic.",
            "dependencies": [
              "28.3"
            ],
            "details": "1. Locate the component containing the login form (e.g., `components/auth/LoginForm.tsx`).\n2. Find the `signIn()` function call that is executed on form submission.\n3. Add the `callbackUrl` option to the second argument of the `signIn` call, setting its value to `'/auth/post-login'`. Example: `signIn('credentials', { ...data, callbackUrl: '/auth/post-login' });`.",
            "status": "pending",
            "testStrategy": "1. Log out completely. Navigate to the login page and sign in with an 'ADMIN' account. Verify you are correctly and automatically redirected to the `/admin` dashboard.\n2. Log out again. Sign in with a regular 'USER' account. Verify you are correctly and automatically redirected to the `/dashboard` page."
          }
        ]
      },
      {
        "id": 29,
        "title": "Implement User File Management System (Upload, List, Update, Delete)",
        "description": "Develop a complete file management system for authenticated users. This includes creating a dedicated UI page and the necessary API endpoints to handle file uploads, display a list of user-owned files, and allow for file renaming and deletion.",
        "details": "This task involves creating a full CRUD (Create, Read, Update, Delete) functionality for user-specific files. 1. **Database Schema**: Add a new `File` model to `prisma/schema.prisma`. It must include fields like `id`, `filename`, `storagePath`, `mimetype`, `size`, `createdAt`, and a relation to the `User` model (`userId String`, `@relation(...)`). Run `npx prisma migrate dev` to apply changes. 2. **Backend API Endpoints**: Create API routes under `app/api/files/`. All routes must be protected and verify that the user performing the action is the owner of the file. - **POST /api/files/upload**: Handle `multipart/form-data` requests. Save the uploaded file to a secure location on the server (e.g., a non-public `uploads` directory) and create a corresponding record in the `File` table, linking it to the authenticated user's ID. - **GET /api/files**: Fetch and return a list of all file records belonging to the currently authenticated user. - **PUT /api/files/[fileId]**: Handle file metadata updates, primarily renaming. It should receive a new `filename` in the request body, validate ownership, and update the database record. - **DELETE /api/files/[fileId]**: Validate ownership, then delete the physical file from the server's storage and remove its corresponding record from the database. 3. **Frontend UI**: Create a new page at `/dashboard/files`. - **File Upload Form**: Implement a form with an `<input type=\"file\">` that submits to the upload endpoint. Provide user feedback on upload progress, success, or failure. - **File List Display**: Use a data fetching hook (like SWR or React Query) to call the `GET /api/files` endpoint. Display the files in a table or grid, showing the filename, upload date, and action buttons (e.g., Rename, Delete, Download). - **Modals for Actions**: Implement modals for renaming a file (pre-filled with the current name) and for confirming deletion to prevent accidental data loss.",
        "testStrategy": "1. **Authorization & Security**: Attempt to access the `/dashboard/files` page while logged out and verify redirection to the login page. Log in as User A, upload a file, and note its ID. Log in as User B and attempt to list, update, or delete User A's file via direct API calls; verify all attempts are rejected with a 403 Forbidden or 404 Not Found error. 2. **Upload Functionality**: Upload a file (e.g., PDF, JPG). Verify it appears in the UI list, is physically present in the server's upload directory, and a corresponding record exists in the database linked to the correct user. 3. **List Functionality**: Upload multiple files. Verify all are correctly listed for the logged-in user. Log in as a different user and confirm their file list is empty or shows only their own files. 4. **Update Functionality**: Use the UI to rename a file. Verify the name changes in the list and the database record is updated. 5. **Delete Functionality**: Use the UI to delete a file. Confirm the deletion prompt appears. After confirming, verify the file is removed from the UI list, deleted from the server's file system, and its record is removed from the database.",
        "status": "pending",
        "dependencies": [
          7,
          8,
          17
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Define and Migrate the `File` Model in Prisma Schema",
            "description": "Create the database schema for storing file metadata. This involves adding a `File` model to `prisma/schema.prisma` and running a migration to apply the changes to the database.",
            "dependencies": [],
            "details": "In `prisma/schema.prisma`, define a new `File` model. It must include fields: `id` (String, @id, @default(cuid())), `filename` (String), `storagePath` (String), `mimetype` (String), `size` (Int), `createdAt` (DateTime, @default(now())), and a relation to the `User` model. Add `userId String` and the relation field `user User @relation(fields: [userId], references: [id], onDelete: Cascade)`. After defining the model, run the command `npx prisma migrate dev --name add_file_model` to generate and apply the migration.",
            "status": "pending",
            "testStrategy": "After migration, use a database client (like Prisma Studio) to verify that the `File` table with the correct columns and relations has been created in the database."
          },
          {
            "id": 2,
            "title": "Create API Endpoint for File Upload (POST /api/files/upload)",
            "description": "Develop a protected API route to handle multipart/form-data file uploads. The endpoint will save the file to a designated server directory and create a corresponding record in the `File` table.",
            "dependencies": [
              "29.1"
            ],
            "details": "Create the route handler at `app/api/files/upload/route.ts`. Use a library like `formidable` or handle the stream directly to process the `multipart/form-data` request. First, verify the user is authenticated using `getServerSession` from NextAuth.js. Generate a unique name for the file to avoid collisions and save it to a non-public directory (e.g., `./uploads`). After successfully saving the file, create a new entry in the `File` table using Prisma, linking it to the authenticated user's ID and storing metadata like the original filename, the new storage path, mimetype, and size. Return a 201 Created response with the new file's data.",
            "status": "pending",
            "testStrategy": "Use an API client like Postman or Insomnia to send a POST request with a valid session cookie and a file in a `multipart/form-data` body. Verify that the file is saved on the server's filesystem and a corresponding record is created in the database. Test error cases like unauthenticated requests or requests without a file."
          },
          {
            "id": 3,
            "title": "Create API Endpoint to List User's Files (GET /api/files)",
            "description": "Develop a protected API route that retrieves and returns a list of all file metadata records associated with the currently authenticated user.",
            "dependencies": [
              "29.1"
            ],
            "details": "Create the route handler at `app/api/files/route.ts`. In the `GET` handler, retrieve the user's session to get their ID. Use Prisma to query the `File` table, filtering by the `userId`. The query should be `prisma.file.findMany({ where: { userId: session.user.id }, orderBy: { createdAt: 'desc' } })`. Return the resulting array of file objects as a JSON response with a 200 OK status. Ensure the route is protected and returns a 401 Unauthorized error if no session is found.",
            "status": "pending",
            "testStrategy": "After uploading a few files using the endpoint from subtask 29.2, make an authenticated GET request to `/api/files`. Verify that the response is a JSON array containing the correct file records for that user. Test that an unauthenticated request receives a 401 error."
          },
          {
            "id": 4,
            "title": "Build the File Management UI Page and Display the File List",
            "description": "Create a new page at `/dashboard/files` and implement the UI to fetch and display the user's files in a table or grid format.",
            "dependencies": [
              "29.3"
            ],
            "details": "Create a new route `app/dashboard/files/page.tsx`. This should be a client component (`'use client'`). Use a data fetching library like SWR or React Query to call the `/api/files` endpoint. While data is loading, show a loading spinner. If there's an error, display an error message. Once the data is fetched, map over the array of files and render them in a table. The table should have columns for `Filename`, `Upload Date`, `Size`, and `Actions` (which will be empty for now). Use a utility function to format the date and file size for display.",
            "status": "pending",
            "testStrategy": "Navigate to `/dashboard/files` while logged in. Verify that a loading state is shown initially, followed by a table displaying the files previously uploaded for the current user. Check that the page is protected by middleware and redirects to login if accessed while logged out."
          },
          {
            "id": 5,
            "title": "Implement the File Upload Form on the Frontend",
            "description": "Add a file upload form to the `/dashboard/files` page that allows users to select and upload a file. Provide feedback on the upload status.",
            "dependencies": [
              "29.2",
              "29.4"
            ],
            "details": "In the `app/dashboard/files/page.tsx` component, add a form with an `<input type=\"file\">` and a submit button. On form submission, prevent the default action and create a `FormData` object. Append the selected file to it. Use the `fetch` API or a library like `axios` to send a POST request to `/api/files/upload` with the `FormData` as the body. Implement state to track the upload progress (e.g., 'idle', 'uploading', 'success', 'error'). Disable the submit button while uploading. Display success or error messages to the user. Upon successful upload, re-fetch the file list to show the newly added file.",
            "status": "pending",
            "testStrategy": "On the `/dashboard/files` page, use the new form to select and upload a file. Verify that the UI shows an 'uploading' state. After the upload completes, confirm that a success message is shown and the file list automatically updates to include the new file."
          },
          {
            "id": 6,
            "title": "Create API Endpoint for File Deletion (DELETE /api/files/[fileId])",
            "description": "Develop a protected API route that handles file deletion. It must verify that the user owns the file before deleting both the physical file from storage and its record from the database.",
            "dependencies": [
              "29.1"
            ],
            "details": "Create a dynamic route handler at `app/api/files/[fileId]/route.ts`. In the `DELETE` handler, get the `fileId` from the route parameters and the user's session. First, query the database for the file: `prisma.file.findUnique({ where: { id: fileId } })`. If the file doesn't exist or if `file.userId` does not match the session's `user.id`, return a 404 Not Found or 403 Forbidden error. If ownership is verified, use Node.js's `fs` module (`fs.promises.unlink`) to delete the physical file from the path specified in `file.storagePath`. After successfully deleting the file, delete the record from the database: `prisma.file.delete({ where: { id: fileId } })`. Return a 204 No Content response on success.",
            "status": "pending",
            "testStrategy": "Using an API client, send an authenticated DELETE request to `/api/files/[fileId]` for a file owned by the user. Verify a 204 response, and confirm the file is gone from both the filesystem and the database. Attempt to delete a file owned by another user and verify a 403/404 error is returned."
          },
          {
            "id": 7,
            "title": "Create API Endpoint for File Renaming (PUT /api/files/[fileId])",
            "description": "Develop a protected API route to update a file's metadata, specifically its name. The endpoint must validate user ownership before updating the database record.",
            "dependencies": [
              "29.1"
            ],
            "details": "In the `app/api/files/[fileId]/route.ts` file, implement the `PUT` handler. It should expect a JSON body with a `filename` property. Get the `fileId` and user session. Find the file in the database and verify ownership, similar to the DELETE endpoint. If ownership is confirmed, use Prisma to update the record: `prisma.file.update({ where: { id: fileId }, data: { filename: newFilename } })`. Return the updated file object with a 200 OK status. Use Zod to validate the incoming `filename` to ensure it's a non-empty string.",
            "status": "pending",
            "testStrategy": "Using an API client, send an authenticated PUT request to `/api/files/[fileId]` with `{\"filename\": \"new-name.txt\"}` in the body. Verify a 200 response containing the updated file data. Check the database to confirm the `filename` field was updated. Test for invalid input and ownership errors."
          },
          {
            "id": 8,
            "title": "Add Rename and Delete Modals and Functionality to the UI",
            "description": "Enhance the file list on the `/dashboard/files` page by adding 'Rename' and 'Delete' buttons. Implement modals for these actions to provide a good user experience and prevent accidental deletion.",
            "dependencies": [
              "29.4",
              "29.6",
              "29.7"
            ],
            "details": "In the `Actions` column of the file table in `app/dashboard/files/page.tsx`, add 'Rename' and 'Delete' buttons for each file. For 'Delete', clicking the button should open a confirmation modal asking 'Are you sure you want to delete this file?'. On confirmation, send a `DELETE` request to `/api/files/[fileId]`. For 'Rename', clicking the button should open a modal with a text input pre-filled with the current filename. On submitting the modal form, send a `PUT` request to `/api/files/[fileId]` with the new name. After either action is successful, re-fetch the file list to update the UI.",
            "status": "pending",
            "testStrategy": "On the file list page, click the 'Delete' button for a file. Verify the confirmation modal appears. Confirm the deletion and check that the file is removed from the list. Click the 'Rename' button for another file. Verify the modal appears with the current name. Enter a new name, submit, and verify the filename updates in the list."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-17T16:02:51.192Z",
      "updated": "2025-09-17T16:02:51.192Z",
      "description": "Copy of \"master\" created on 17/9/2025",
      "copiedFrom": {
        "tag": "master",
        "date": "2025-09-17T16:02:51.192Z"
      }
    }
  }
}